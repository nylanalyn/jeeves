{"type":"file-history-snapshot","messageId":"f281ea56-6784-4145-baa8-1ade32f9562f","snapshot":{"messageId":"f281ea56-6784-4145-baa8-1ade32f9562f","trackedFileBackups":{},"timestamp":"2026-02-12T01:13:28.908Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"entire hooks claude-code session-start"},"parentToolUseID":"c21d6c79-24ba-41e1-beeb-ddf5532e4fab","toolUseID":"c21d6c79-24ba-41e1-beeb-ddf5532e4fab","timestamp":"2026-02-12T01:09:27.859Z","uuid":"b7801ff1-996b-46ee-beb2-a2cfa4a7a189"}
{"parentUuid":"b7801ff1-996b-46ee-beb2-a2cfa4a7a189","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"${CLAUDE_PLUGIN_ROOT}/hooks/session-start.sh"},"parentToolUseID":"c21d6c79-24ba-41e1-beeb-ddf5532e4fab","toolUseID":"c21d6c79-24ba-41e1-beeb-ddf5532e4fab","timestamp":"2026-02-12T01:09:27.870Z","uuid":"8c8c49a8-1819-448f-baef-25c1bb40f900"}
{"parentUuid":"8c8c49a8-1819-448f-baef-25c1bb40f900","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","type":"user","message":{"role":"user","content":"In the in the modules/fishing.py file, there is a command !water that lets a person say when they have finished a drink of water, and if they have done so it gives them a boost to catching rares in the fishing game. It was MEANT to be a nice reminder to hydrate, but now people are just saying it four times and then using the boost. I want to add a delay. So you can do it four times, but you have to have at least an hour between using the !water command. jeeves needs to aknowledge the attempt, but suggest they are cheating, because there is no way they drank a water that fast. Preferably in a funny, snarky, PG Wodehouse Jeeves style."},"uuid":"f281ea56-6784-4145-baa8-1ade32f9562f","timestamp":"2026-02-12T01:13:28.280Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"f281ea56-6784-4145-baa8-1ade32f9562f","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","message":{"model":"claude-opus-4-6","id":"msg_01UwjYZf1M6Qng6iZQaq4zVo","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nLet me read the fishing module to understand the current implementation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2121,"cache_read_input_tokens":18170,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2121},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HdcKEJ6FtANTKa5MqY","type":"assistant","uuid":"4413f3e4-c82b-4863-a4f8-15900e78df69","timestamp":"2026-02-12T01:13:31.483Z"}
{"parentUuid":"4413f3e4-c82b-4863-a4f8-15900e78df69","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01UwjYZf1M6Qng6iZQaq4zVo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VmFdGAatn9CR8bGLWsvsdB","name":"Read","input":{"file_path":"/home/nylan/code/jeeves/modules/fishing.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2121,"cache_read_input_tokens":18170,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2121},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HdcKEJ6FtANTKa5MqY","type":"assistant","uuid":"b9da99e7-8582-4c42-a251-67b07dba23cf","timestamp":"2026-02-12T01:13:31.861Z"}
{"parentUuid":"b9da99e7-8582-4c42-a251-67b07dba23cf","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VmFdGAatn9CR8bGLWsvsdB","toolUseID":"toolu_01VmFdGAatn9CR8bGLWsvsdB","timestamp":"2026-02-12T01:13:32.041Z","uuid":"98f3e642-742b-4580-baa9-c1b9c7ca1bef"}
{"parentUuid":"b9da99e7-8582-4c42-a251-67b07dba23cf","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VmFdGAatn9CR8bGLWsvsdB","type":"tool_result","content":"     1→# modules/fishing.py\n     2→# A fishing mini-game where users cast lines and reel in catches over time.\n     3→\n     4→import random\n     5→import re\n     6→from datetime import datetime, timezone, timedelta\n     7→from typing import Any, Dict, List, Optional, Tuple\n     8→\n     9→from .base import SimpleCommandModule\n    10→from . import achievement_hooks\n    11→\n    12→UTC = timezone.utc\n    13→\n    14→\n    15→def setup(bot: Any) -> 'Fishing':\n    16→    return Fishing(bot)\n    17→\n    18→\n    19→# Fishing locations unlocked by level (0-9)\n    20→LOCATIONS = [\n    21→    {\"name\": \"Puddle\", \"level\": 0, \"max_distance\": 5, \"type\": \"terrestrial\"},\n    22→    {\"name\": \"Pond\", \"level\": 1, \"max_distance\": 15, \"type\": \"terrestrial\"},\n    23→    {\"name\": \"Lake\", \"level\": 2, \"max_distance\": 30, \"type\": \"terrestrial\"},\n    24→    {\"name\": \"River\", \"level\": 3, \"max_distance\": 50, \"type\": \"terrestrial\"},\n    25→    {\"name\": \"Ocean\", \"level\": 4, \"max_distance\": 100, \"type\": \"terrestrial\"},\n    26→    {\"name\": \"Deep Sea\", \"level\": 5, \"max_distance\": 200, \"type\": \"terrestrial\"},\n    27→    {\"name\": \"Moon\", \"level\": 6, \"max_distance\": 500, \"type\": \"space\"},\n    28→    {\"name\": \"Mars\", \"level\": 7, \"max_distance\": 1000, \"type\": \"space\"},\n    29→    {\"name\": \"Jupiter\", \"level\": 8, \"max_distance\": 2000, \"type\": \"space\"},\n    30→    {\"name\": \"The Void\", \"level\": 9, \"max_distance\": 5000, \"type\": \"space\"},\n    31→]\n    32→\n    33→# Fish database organized by location\n    34→# Each fish has: name, min_weight, max_weight, rarity\n    35→FISH_DATABASE: Dict[str, List[Dict[str, Any]]] = {\n    36→    \"Puddle\": [\n    37→        # Common\n    38→        {\"name\": \"Minnow\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n    39→        {\"name\": \"Tadpole\", \"min_weight\": 0.05, \"max_weight\": 0.2, \"rarity\": \"common\"},\n    40→        {\"name\": \"Guppy\", \"min_weight\": 0.1, \"max_weight\": 0.3, \"rarity\": \"common\"},\n    41→        {\"name\": \"Water Beetle\", \"min_weight\": 0.01, \"max_weight\": 0.1, \"rarity\": \"common\"},\n    42→        # Uncommon\n    43→        {\"name\": \"Goldfish\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"uncommon\"},\n    44→        {\"name\": \"Small Frog\", \"min_weight\": 0.3, \"max_weight\": 1.0, \"rarity\": \"uncommon\"},\n    45→        # Rare\n    46→        {\"name\": \"Koi\", \"min_weight\": 2.0, \"max_weight\": 5.0, \"rarity\": \"rare\"},\n    47→        # Legendary\n    48→        {\"name\": \"The Puddle King\", \"min_weight\": 8.0, \"max_weight\": 15.0, \"rarity\": \"legendary\"},\n    49→    ],\n    50→    \"Pond\": [\n    51→        # Common\n    52→        {\"name\": \"Bluegill\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n    53→        {\"name\": \"Perch\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n    54→        {\"name\": \"Sunfish\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n    55→        {\"name\": \"Crayfish\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n    56→        # Uncommon\n    57→        {\"name\": \"Largemouth Bass\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"uncommon\"},\n    58→        {\"name\": \"Catfish\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"uncommon\"},\n    59→        # Rare\n    60→        {\"name\": \"Golden Perch\", \"min_weight\": 5.0, \"max_weight\": 12.0, \"rarity\": \"rare\"},\n    61→        # Legendary\n    62→        {\"name\": \"Old Whiskers\", \"min_weight\": 20.0, \"max_weight\": 40.0, \"rarity\": \"legendary\"},\n    63→    ],\n    64→    \"Lake\": [\n    65→        # Common\n    66→        {\"name\": \"Trout\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n    67→        {\"name\": \"Crappie\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n    68→        {\"name\": \"Walleye\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n    69→        {\"name\": \"Pike\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n    70→        # Uncommon\n    71→        {\"name\": \"Lake Sturgeon\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n    72→        {\"name\": \"Muskie\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n    73→        # Rare\n    74→        {\"name\": \"Albino Sturgeon\", \"min_weight\": 20.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n    75→        # Legendary\n    76→        {\"name\": \"Nessie's Cousin\", \"min_weight\": 100.0, \"max_weight\": 200.0, \"rarity\": \"legendary\"},\n    77→    ],\n    78→    \"River\": [\n    79→        # Common\n    80→        {\"name\": \"Salmon\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n    81→        {\"name\": \"Steelhead\", \"min_weight\": 4.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n    82→        {\"name\": \"River Carp\", \"min_weight\": 3.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n    83→        {\"name\": \"Smallmouth Bass\", \"min_weight\": 2.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n    84→        # Uncommon\n    85→        {\"name\": \"King Salmon\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n    86→        {\"name\": \"Paddlefish\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n    87→        # Rare\n    88→        {\"name\": \"Golden Salmon\", \"min_weight\": 25.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n    89→        # Legendary\n    90→        {\"name\": \"The River Guardian\", \"min_weight\": 80.0, \"max_weight\": 150.0, \"rarity\": \"legendary\"},\n    91→    ],\n    92→    \"Ocean\": [\n    93→        # Common\n    94→        {\"name\": \"Tuna\", \"min_weight\": 20.0, \"max_weight\": 80.0, \"rarity\": \"common\"},\n    95→        {\"name\": \"Mackerel\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n    96→        {\"name\": \"Sea Bass\", \"min_weight\": 10.0, \"max_weight\": 40.0, \"rarity\": \"common\"},\n    97→        {\"name\": \"Flounder\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n    98→        # Uncommon\n    99→        {\"name\": \"Swordfish\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n   100→        {\"name\": \"Mahi-Mahi\", \"min_weight\": 15.0, \"max_weight\": 50.0, \"rarity\": \"uncommon\"},\n   101→        {\"name\": \"Barracuda\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n   102→        # Rare\n   103→        {\"name\": \"Blue Marlin\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n   104→        {\"name\": \"Sailfish\", \"min_weight\": 80.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n   105→        # Legendary\n   106→        {\"name\": \"Moby Dick Jr.\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n   107→    ],\n   108→    \"Deep Sea\": [\n   109→        # Common\n   110→        {\"name\": \"Anglerfish\", \"min_weight\": 5.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n   111→        {\"name\": \"Viperfish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n   112→        {\"name\": \"Gulper Eel\", \"min_weight\": 3.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n   113→        {\"name\": \"Lanternfish\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n   114→        # Uncommon\n   115→        {\"name\": \"Giant Squid\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"uncommon\"},\n   116→        {\"name\": \"Oarfish\", \"min_weight\": 30.0, \"max_weight\": 100.0, \"rarity\": \"uncommon\"},\n   117→        {\"name\": \"Goblin Shark\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"uncommon\"},\n   118→        # Rare\n   119→        {\"name\": \"Colossal Squid\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n   120→        {\"name\": \"Megamouth Shark\", \"min_weight\": 300.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n   121→        # Legendary\n   122→        {\"name\": \"The Kraken\", \"min_weight\": 1000.0, \"max_weight\": 2500.0, \"rarity\": \"legendary\"},\n   123→    ],\n   124→    \"Moon\": [\n   125→        # Common\n   126→        {\"name\": \"Moon Jellyfish\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n   127→        {\"name\": \"Lunar Shrimp\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n   128→        {\"name\": \"Crater Minnow\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n   129→        {\"name\": \"Dust Swimmer\", \"min_weight\": 1.0, \"max_weight\": 4.0, \"rarity\": \"common\"},\n   130→        # Uncommon\n   131→        {\"name\": \"Crater Crab\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"uncommon\"},\n   132→        {\"name\": \"Void Eel\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n   133→        {\"name\": \"Selenite Fish\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n   134→        # Rare\n   135→        {\"name\": \"Cosmic Whale\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n   136→        {\"name\": \"Starlight Serpent\", \"min_weight\": 40.0, \"max_weight\": 150.0, \"rarity\": \"rare\"},\n   137→        # Legendary\n   138→        {\"name\": \"The Leviathan of Tranquility\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n   139→    ],\n   140→    \"Mars\": [\n   141→        # Common\n   142→        {\"name\": \"Rust Minnow\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n   143→        {\"name\": \"Red Silt Crawler\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n   144→        {\"name\": \"Iron Guppy\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n   145→        {\"name\": \"Dust Devil Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n   146→        # Uncommon\n   147→        {\"name\": \"Olympus Bass\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n   148→        {\"name\": \"Valles Trout\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n   149→        {\"name\": \"Phobos Flounder\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n   150→        # Rare\n   151→        {\"name\": \"Martian Kraken\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n   152→        {\"name\": \"Red Planet Leviathan\", \"min_weight\": 150.0, \"max_weight\": 400.0, \"rarity\": \"rare\"},\n   153→        # Legendary\n   154→        {\"name\": \"The Ancient One\", \"min_weight\": 1000.0, \"max_weight\": 2000.0, \"rarity\": \"legendary\"},\n   155→    ],\n   156→    \"Jupiter\": [\n   157→        # Common\n   158→        {\"name\": \"Gas Giant Jellyfish\", \"min_weight\": 2.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n   159→        {\"name\": \"Storm Swimmer\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n   160→        {\"name\": \"Ammonia Minnow\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n   161→        {\"name\": \"Cloud Drifter\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n   162→        # Uncommon\n   163→        {\"name\": \"Red Spot Ray\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n   164→        {\"name\": \"Ammonia Eel\", \"min_weight\": 30.0, \"max_weight\": 80.0, \"rarity\": \"uncommon\"},\n   165→        {\"name\": \"Io Salmon\", \"min_weight\": 25.0, \"max_weight\": 70.0, \"rarity\": \"uncommon\"},\n   166→        # Rare\n   167→        {\"name\": \"Jovian Leviathan\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n   168→        {\"name\": \"Europa Ice Beast\", \"min_weight\": 250.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n   169→        # Legendary\n   170→        {\"name\": \"The Great Red Serpent\", \"min_weight\": 2000.0, \"max_weight\": 4000.0, \"rarity\": \"legendary\"},\n   171→    ],\n   172→    \"The Void\": [\n   173→        # Common\n   174→        {\"name\": \"Void Mite\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n   175→        {\"name\": \"Dark Matter Shrimp\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n   176→        {\"name\": \"Null Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n   177→        {\"name\": \"Entropy Minnow\", \"min_weight\": 1.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n   178→        # Uncommon\n   179→        {\"name\": \"Entropy Eel\", \"min_weight\": 25.0, \"max_weight\": 75.0, \"rarity\": \"uncommon\"},\n   180→        {\"name\": \"Singularity Squid\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n   181→        {\"name\": \"Dimensional Drifter\", \"min_weight\": 40.0, \"max_weight\": 120.0, \"rarity\": \"uncommon\"},\n   182→        # Rare\n   183→        {\"name\": \"Reality Warper\", \"min_weight\": 300.0, \"max_weight\": 800.0, \"rarity\": \"rare\"},\n   184→        {\"name\": \"Event Horizon Eel\", \"min_weight\": 400.0, \"max_weight\": 900.0, \"rarity\": \"rare\"},\n   185→        # Legendary\n   186→        {\"name\": \"The Cosmic Horror\", \"min_weight\": 5000.0, \"max_weight\": 10000.0, \"rarity\": \"legendary\"},\n   187→        {\"name\": \"Cthulhu's Cousin\", \"min_weight\": 8000.0, \"max_weight\": 15000.0, \"rarity\": \"legendary\"},\n   188→    ],\n   189→}\n   190→\n   191→# Junk items by location type\n   192→JUNK_ITEMS: Dict[str, List[str]] = {\n   193→    \"terrestrial\": [\n   194→        \"Old Boot\", \"Rusty Tin Can\", \"Soggy Newspaper\", \"Tangled Fishing Line\",\n   195→        \"Broken Sunglasses\", \"Waterlogged Book\", \"Deflated Beach Ball\", \"Lost Flip-Flop\",\n   196→        \"Shopping Cart Wheel\", \"Plastic Bottle\", \"Tire\", \"Underwear\", \"License Plate\",\n   197→        \"Broken Umbrella\", \"Moldy Wallet\", \"Damp Cigarette Pack\", \"Fishing Bobber\",\n   198→        \"Knitting Needle\", \"Crochet Hook\", \"Tangled Yarn Ball\", \"Stitch Marker\",\n   199→        \"Frayed Crochet Bag\", \"Half-Finished Scarf\", \"Pattern Printout\",\n   200→        \"Game Controller\", \"Pixelated Cartridge\", \"Arcade Token\", \"Headset Mic\",\n   201→        \"Trophy Cup\", \"Resistance Band\", \"Kettlebell\", \"Gym Towel\",\n   202→        \"Protein Shaker\", \"Yoga Mat\", \"Jump Rope\",\n   203→    ],\n   204→    \"space\": [\n   205→        \"Space Debris\", \"Frozen Oxygen Chunk\", \"Abandoned Satellite\", \"Lost Astronaut Glove\",\n   206→        \"Alien Artifact\", \"Meteor Fragment\", \"Cosmic Dust Bunny\", \"Derelict Probe\",\n   207→        \"Ancient Star Map\", \"Fossilized Moonrock\", \"Mysterious Orb\", \"Quantum Fluctuation\",\n   208→        \"Void Crystal\", \"Broken Warp Core\", \"Lost Space Buoy\", \"Crystallized Stardust\",\n   209→        \"Zero-G Yarn Ball\", \"Starlight Crochet Hook\", \"Orbital Knitting Needle\",\n   210→        \"Cosmic Game Controller\", \"Nebula Cartridge\", \"Warped Arcade Token\",\n   211→        \"Anti-Gravity Kettlebell\", \"Meteorite Dumbbell\", \"Vacuum-Sealed Gym Towel\",\n   212→        \"Protein Paste Packet\", \"Quantum Jump Rope\",\n   213→    ],\n   214→}\n   215→\n   216→# Random events that can trigger\n   217→EVENTS: Dict[str, Dict[str, Any]] = {\n   218→    \"full_moon\": {\n   219→        \"name\": \"Full Moon\",\n   220→        \"description\": \"The full moon rises! Rare fish are more active.\",\n   221→        \"effect\": \"rare_boost\",\n   222→        \"multiplier\": 2.0,\n   223→        \"duration_minutes\": 30,\n   224→    },\n   225→    \"solar_flare\": {\n   226→        \"name\": \"Solar Flare\",\n   227→        \"description\": \"A solar flare energizes the waters! Double XP!\",\n   228→        \"effect\": \"xp_boost\",\n   229→        \"multiplier\": 2.0,\n   230→        \"duration_minutes\": 20,\n   231→        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n   232→    },\n   233→    \"feeding_frenzy\": {\n   234→        \"name\": \"Feeding Frenzy\",\n   235→        \"description\": \"The fish are hungry! Catches are easier.\",\n   236→        \"effect\": \"time_boost\",\n   237→        \"multiplier\": 0.5,  # Halves effective required time\n   238→        \"duration_minutes\": 25,\n   239→    },\n   240→    \"murky_waters\": {\n   241→        \"name\": \"Murky Waters\",\n   242→        \"description\": \"The waters are murky... more junk than usual.\",\n   243→        \"effect\": \"junk_boost\",\n   244→        \"multiplier\": 2.0,\n   245→        \"duration_minutes\": 15,\n   246→    },\n   247→    \"meteor_shower\": {\n   248→        \"name\": \"Meteor Shower\",\n   249→        \"description\": \"A meteor shower brings strange creatures from beyond!\",\n   250→        \"effect\": \"alien_fish\",\n   251→        \"duration_minutes\": 20,\n   252→        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n   253→    },\n   254→}\n   255→\n   256→# Rarity weights for fish selection\n   257→RARITY_WEIGHTS = {\n   258→    \"common\": 70,\n   259→    \"uncommon\": 20,\n   260→    \"rare\": 8,\n   261→    \"legendary\": 2,\n   262→}\n   263→\n   264→# XP multipliers by rarity\n   265→RARITY_XP_MULTIPLIER = {\n   266→    \"common\": 1,\n   267→    \"uncommon\": 2,\n   268→    \"rare\": 5,\n   269→    \"legendary\": 20,\n   270→}\n   271→\n   272→# XP bonus chances (per successful catch)\n   273→XP_BONUS_SMALL_CHANCE = 0.04\n   274→XP_BONUS_LARGE_CHANCE = 0.01\n   275→XP_BOOST_ROD_CHANCE = 0.007\n   276→XP_BOOST_ROD_CATCHES = 5\n   277→XP_BOOST_MULTIPLIER = 2\n   278→XP_BONUS_SMALL_RANGE = (8, 20)\n   279→XP_BONUS_LARGE_RANGE = (40, 90)\n   280→\n   281→# Cast flavor messages\n   282→CAST_MESSAGES = [\n   283→    \"You cast your line, it goes {distance}m and floats quietly...\",\n   284→    \"With a practiced flick, your line sails {distance}m into the {location}.\",\n   285→    \"Your line arcs gracefully, landing {distance}m away in the {location}.\",\n   286→    \"The line whips through the air, settling {distance}m out.\",\n   287→    \"You send your line sailing {distance}m. Now we wait...\",\n   288→]\n   289→\n   290→# Reel too early messages\n   291→TOO_EARLY_MESSAGES = [\n   292→    \"You reel in too soon - the line is empty. Perhaps patience is a virtue?\",\n   293→    \"Nothing but an empty hook. The fish need more time to find your bait.\",\n   294→    \"Your line comes back bare. Try waiting a bit longer next time.\",\n   295→    \"Too hasty! The fish haven't even noticed your bait yet.\",\n   296→    \"An empty catch. Good things come to those who wait.\",\n   297→]\n   298→\n   299→# Danger zone messages (over 24 hours)\n   300→DANGER_ZONE_MESSAGES = {\n   301→    \"line_break\": [\n   302→        \"The line finally snaps from the strain! It was out there too long.\",\n   303→        \"Your line, weakened by time, breaks as you try to reel in.\",\n   304→        \"The elements have taken their toll - your line breaks clean off!\",\n   305→    ],\n   306→    \"fish_escaped\": [\n   307→        \"The fish got tired of waiting and swam away ages ago.\",\n   308→        \"Whatever was on the line has long since escaped.\",\n   309→        \"You reel in... nothing. The fish left hours ago.\",\n   310→    ],\n   311→    \"junk\": [\n   312→        \"After all that time, you only catch some waterlogged junk.\",\n   313→        \"The long wait rewards you with... garbage. How fitting.\",\n   314→    ],\n   315→}\n   316→\n   317→\n   318→class Fishing(SimpleCommandModule):\n   319→    name = \"fishing\"\n   320→    version = \"1.0.0\"\n   321→    description = \"A fishing mini-game with locations, leveling, and rare catches.\"\n   322→\n   323→    # Time thresholds in hours\n   324→    MIN_WAIT_HOURS = 1.0\n   325→    OPTIMAL_WAIT_HOURS = 24.0\n   326→    DANGER_THRESHOLD_HOURS = 24.0\n   327→    MAX_DANGER_HOURS = 48.0\n   328→\n   329→    def __init__(self, bot: Any) -> None:\n   330→        super().__init__(bot)\n   331→\n   332→        # Initialize state\n   333→        if not self.get_state(\"active_casts\"):\n   334→            self.set_state(\"active_casts\", {})\n   335→        if not self.get_state(\"players\"):\n   336→            self.set_state(\"players\", {})\n   337→        if not self.get_state(\"active_event\"):\n   338→            self.set_state(\"active_event\", None)\n   339→        self.save_state()\n   340→\n   341→    def _register_commands(self) -> None:\n   342→        self.register_command(\n   343→            r'^\\s*!cast(?:\\s+(.+))?\\s*$',\n   344→            self._cmd_cast,\n   345→            name=\"cast\",\n   346→            description=\"Cast your fishing line (optionally specify location)\"\n   347→        )\n   348→        self.register_command(\n   349→            r'^\\s*!reel\\s*$',\n   350→            self._cmd_reel,\n   351→            name=\"reel\",\n   352→            description=\"Reel in your catch\"\n   353→        )\n   354→        self.register_command(\n   355→            r'^\\s*!fish(?:ing|stats)?\\s*$',\n   356→            self._cmd_fishing_stats,\n   357→            name=\"fishing\",\n   358→            description=\"Show your fishing statistics\"\n   359→        )\n   360→        self.register_command(\n   361→            r'^\\s*!fish(?:ing)?\\s+top\\s*$',\n   362→            self._cmd_fishing_top,\n   363→            name=\"fishing top\",\n   364→            description=\"Show fishing leaderboards\"\n   365→        )\n   366→        self.register_command(\n   367→            r'^\\s*!fish(?:ing)?\\s+location\\s*$',\n   368→            self._cmd_fishing_location,\n   369→            name=\"fishing location\",\n   370→            description=\"Show your current fishing location\"\n   371→        )\n   372→        self.register_command(\n   373→            r'^\\s*!fishinfo(?:\\s+(.+))?\\s*$',\n   374→            self._cmd_fishinfo,\n   375→            name=\"fishinfo\",\n   376→            description=\"Show fish caught in a specific location\"\n   377→        )\n   378→        self.register_command(\n   379→            r'^\\s*!aquarium\\s*$',\n   380→            self._cmd_aquarium,\n   381→            name=\"aquarium\",\n   382→            description=\"Show your rare and legendary catches\"\n   383→        )\n   384→        self.register_command(\n   385→            r'^\\s*!fish(?:ing)?\\s+help\\s*$',\n   386→            self._cmd_fishing_help,\n   387→            name=\"fishing help\",\n   388→            description=\"Show fishing help\"\n   389→        )\n   390→        self.register_command(\n   391→            r'^\\s*!fish(?:ing)?\\s+bless\\s+(\\S+)\\s*$',\n   392→            self._cmd_fishing_bless,\n   393→            name=\"fishing bless\",\n   394→            admin_only=True,\n   395→            description=\"[Admin] Guarantee a user's next catch is rare or legendary\"\n   396→        )\n   397→        self.register_command(\n   398→            r'^\\s*!water\\s*$',\n   399→            self._cmd_water,\n   400→            name=\"water\",\n   401→            description=\"Celebrate finishing a water bottle (boosts rare fish chances)\"\n   402→        )\n   403→\n   404→    def _get_player(self, user_id: str) -> Dict[str, Any]:\n   405→        \"\"\"Get or create a player record.\"\"\"\n   406→        players = self.get_state(\"players\", {})\n   407→        if user_id not in players:\n   408→            players[user_id] = {\n   409→                \"level\": 0,\n   410→                \"xp\": 0,\n   411→                \"total_fish\": 0,\n   412→                \"biggest_fish\": 0.0,\n   413→                \"biggest_fish_name\": None,\n   414→                \"total_casts\": 0,\n   415→                \"furthest_cast\": 0.0,\n   416→                \"lines_broken\": 0,\n   417→                \"junk_collected\": 0,\n   418→                \"catches\": {},\n   419→                \"catches_by_location\": {},  # {\"location_name\": {\"fish_name\": count}}\n   420→                \"rare_catches\": [],\n   421→                \"locations_fished\": [],\n   422→                \"water_today\": 0,  # Number of water bottles consumed today\n   423→                \"water_date\": None,  # Date of last water consumption (for daily reset)\n   424→                \"xp_boost_catches\": 0,\n   425→                \"force_rare_legendary\": False,\n   426→            }\n   427→            self.set_state(\"players\", players)\n   428→            self.save_state()\n   429→        return players[user_id]\n   430→\n   431→    def _save_player(self, user_id: str, player: Dict[str, Any]) -> None:\n   432→        \"\"\"Save a player record.\"\"\"\n   433→        players = self.get_state(\"players\", {})\n   434→        players[user_id] = player\n   435→        self.set_state(\"players\", players)\n   436→        self.save_state()\n   437→\n   438→    def _get_location_for_level(self, level: int) -> Dict[str, Any]:\n   439→        \"\"\"Get the location a player can fish at based on their level.\"\"\"\n   440→        # Player fishes at their max unlocked location\n   441→        for loc in reversed(LOCATIONS):\n   442→            if loc[\"level\"] <= level:\n   443→                return loc\n   444→        return LOCATIONS[0]\n   445→\n   446→    def _find_location_by_name(self, location_query: str) -> Optional[Dict[str, Any]]:\n   447→        \"\"\"Find a location by name (case-insensitive, supports partial matches).\"\"\"\n   448→        query = location_query.strip().lower()\n   449→        \n   450→        # Try exact match first\n   451→        for loc in LOCATIONS:\n   452→            if loc[\"name\"].lower() == query:\n   453→                return loc\n   454→        \n   455→        # Try partial match\n   456→        for loc in LOCATIONS:\n   457→            if query in loc[\"name\"].lower():\n   458→                return loc\n   459→        \n   460→        return None\n   461→\n   462→    def _get_xp_for_level(self, level: int) -> int:\n   463→        \"\"\"Calculate XP needed for a level.\"\"\"\n   464→        return int(100 * ((level + 1) ** 1.5))\n   465→\n   466→    def _check_level_up(self, user_id: str, player: Dict[str, Any], username: str) -> Optional[int]:\n   467→        \"\"\"Check if player leveled up, return new level if so.\"\"\"\n   468→        current_level = player[\"level\"]\n   469→        xp = player[\"xp\"]\n   470→\n   471→        while current_level < 9:  # Max level is 9\n   472→            xp_needed = self._get_xp_for_level(current_level)\n   473→            if xp >= xp_needed:\n   474→                xp -= xp_needed\n   475→                current_level += 1\n   476→            else:\n   477→                break\n   478→\n   479→        if current_level > player[\"level\"]:\n   480→            player[\"level\"] = current_level\n   481→            player[\"xp\"] = xp\n   482→            self._save_player(user_id, player)\n   483→            # Record achievement progress\n   484→            achievement_hooks.record_fishing_level(self.bot, username, current_level)\n   485→            return current_level\n   486→\n   487→        player[\"xp\"] = xp\n   488→        return None\n   489→\n   490→    def _get_cast_distance(self, level: int, location: Dict[str, Any]) -> float:\n   491→        \"\"\"Generate a random cast distance based on level and location.\"\"\"\n   492→        max_dist = location[\"max_distance\"]\n   493→        # Base distance is 30-70% of max, with level adding potential\n   494→        min_dist = max_dist * 0.3\n   495→        level_bonus = (level / 9) * 0.3  # Up to 30% bonus at max level\n   496→        base_max = max_dist * (0.7 + level_bonus)\n   497→        return round(random.uniform(min_dist, base_max), 1)\n   498→\n   499→    def _select_rarity(self, wait_hours: float, event: Optional[Dict[str, Any]] = None, water_boost: float = 0.0) -> str:\n   500→        \"\"\"Select a rarity tier based on wait time, active events, and hydration boost.\"\"\"\n   501→        weights = RARITY_WEIGHTS.copy()\n   502→\n   503→        # Adjust weights based on wait time\n   504→        # < 6 hours: only common really\n   505→        # 6-12: uncommon possible\n   506→        # 12-18: rare possible\n   507→        # 18-24: legendary possible\n   508→\n   509→        if wait_hours < 6:\n   510→            weights[\"uncommon\"] = 5\n   511→            weights[\"rare\"] = 0\n   512→            weights[\"legendary\"] = 0\n   513→        elif wait_hours < 12:\n   514→            weights[\"rare\"] = 2\n   515→            weights[\"legendary\"] = 0\n   516→        elif wait_hours < 18:\n   517→            weights[\"legendary\"] = 0\n   518→        # else: full weights at 18+ hours\n   519→\n   520→        # Apply event bonuses\n   521→        if event and event.get(\"effect\") == \"rare_boost\":\n   522→            weights[\"rare\"] = int(weights[\"rare\"] * event.get(\"multiplier\", 1))\n   523→            weights[\"legendary\"] = int(weights[\"legendary\"] * event.get(\"multiplier\", 1))\n   524→\n   525→        # Apply water boost (increases rare and legendary chances)\n   526→        if water_boost > 0:\n   527→            # Reduce common weight by the boost percentage\n   528→            common_reduction = weights[\"common\"] * water_boost\n   529→            weights[\"common\"] = max(1, int(weights[\"common\"] - common_reduction))\n   530→            \n   531→            # Distribute the reduction to rare and legendary\n   532→            weights[\"rare\"] = int(weights[\"rare\"] + common_reduction * 0.6)\n   533→            weights[\"legendary\"] = int(weights[\"legendary\"] + common_reduction * 0.4)\n   534→\n   535→        # Weighted random selection\n   536→        total = sum(weights.values())\n   537→        roll = random.randint(1, total)\n   538→        cumulative = 0\n   539→        for rarity, weight in weights.items():\n   540→            cumulative += weight\n   541→            if roll <= cumulative:\n   542→                return rarity\n   543→        return \"common\"\n   544→\n   545→    def _select_fish(\n   546→        self,\n   547→        location: str,\n   548→        rarity: str,\n   549→        eligible_locations: Optional[List[str]] = None,\n   550→        allow_fallback: bool = True,\n   551→    ) -> Optional[Dict[str, Any]]:\n   552→        \"\"\"Select a fish from the eligible location pools matching the rarity.\"\"\"\n   553→        if eligible_locations:\n   554→            fish_pool = []\n   555→            for loc_name in eligible_locations:\n   556→                fish_pool.extend(FISH_DATABASE.get(loc_name, []))\n   557→        else:\n   558→            fish_pool = FISH_DATABASE.get(location, [])\n   559→        matching = [f for f in fish_pool if f[\"rarity\"] == rarity]\n   560→        if not matching and allow_fallback:\n   561→            # Fall back to common if no fish of that rarity\n   562→            matching = [f for f in fish_pool if f[\"rarity\"] == \"common\"]\n   563→        if not matching:\n   564→            return None\n   565→        return random.choice(matching)\n   566→\n   567→    def _calculate_weight(self, fish: Dict[str, Any], wait_hours: float) -> float:\n   568→        \"\"\"Calculate actual fish weight based on wait time.\"\"\"\n   569→        min_w = fish[\"min_weight\"]\n   570→        max_w = fish[\"max_weight\"]\n   571→\n   572→        # Weight scales with wait time up to 24 hours\n   573→        time_factor = min(wait_hours / self.OPTIMAL_WAIT_HOURS, 1.0)\n   574→\n   575→        # Random variance within the range, biased by time factor\n   576→        base_weight = min_w + (max_w - min_w) * time_factor\n   577→        variance = (max_w - min_w) * 0.2  # 20% variance\n   578→        weight = base_weight + random.uniform(-variance, variance)\n   579→\n   580→        return round(max(min_w, min(max_w, weight)), 2)\n   581→\n   582→    def _get_junk(self, location_type: str) -> str:\n   583→        \"\"\"Get a random junk item.\"\"\"\n   584→        items = JUNK_ITEMS.get(location_type, JUNK_ITEMS[\"terrestrial\"])\n   585→        return random.choice(items)\n   586→\n   587→    def _check_event_trigger(self, channel: str, location: str) -> Optional[Dict[str, Any]]:\n   588→        \"\"\"5% chance to trigger a random event on cast.\"\"\"\n   589→        if random.random() > 0.05:\n   590→            return None\n   591→\n   592→        # Select a random event\n   593→        available_events = []\n   594→        for event_id, event in EVENTS.items():\n   595→            # Check if event is location-restricted\n   596→            if \"locations\" in event and location not in event[\"locations\"]:\n   597→                continue\n   598→            available_events.append((event_id, event))\n   599→\n   600→        if not available_events:\n   601→            return None\n   602→\n   603→        event_id, event = random.choice(available_events)\n   604→        expires = datetime.now(UTC) + timedelta(minutes=event[\"duration_minutes\"])\n   605→\n   606→        active_event = {\n   607→            \"type\": event_id,\n   608→            \"name\": event[\"name\"],\n   609→            \"description\": event[\"description\"],\n   610→            \"effect\": event.get(\"effect\"),\n   611→            \"multiplier\": event.get(\"multiplier\", 1.0),\n   612→            \"expires\": expires.isoformat(),\n   613→            \"announced_channels\": [channel],\n   614→        }\n   615→\n   616→        self.set_state(\"active_event\", active_event)\n   617→        self.save_state()\n   618→\n   619→        return active_event\n   620→\n   621→    def _get_active_event(self, location: str) -> Optional[Dict[str, Any]]:\n   622→        \"\"\"Get the currently active event if any and valid for location.\"\"\"\n   623→        event = self.get_state(\"active_event\")\n   624→        if not event:\n   625→            return None\n   626→\n   627→        # Check if expired\n   628→        expires = datetime.fromisoformat(event[\"expires\"])\n   629→        if datetime.now(UTC) >= expires:\n   630→            self.set_state(\"active_event\", None)\n   631→            self.save_state()\n   632→            return None\n   633→\n   634→        # Check location restriction\n   635→        event_data = EVENTS.get(event[\"type\"], {})\n   636→        if \"locations\" in event_data and location not in event_data[\"locations\"]:\n   637→            return None\n   638→\n   639→        return event\n   640→\n   641→    def _get_water_boost(self, player: Dict[str, Any]) -> float:\n   642→        \"\"\"Get the current water boost percentage (0.0 to 0.4 for 0% to 40%).\"\"\"\n   643→        # Check if we need to reset daily counter\n   644→        today = datetime.now(UTC).date().isoformat()\n   645→        water_date = player.get(\"water_date\")\n   646→        \n   647→        if water_date != today:\n   648→            # New day, reset counter\n   649→            return 0.0\n   650→        \n   651→        # Each water bottle adds 10% boost, max 4 bottles = 40%\n   652→        water_count = player.get(\"water_today\", 0)\n   653→        return min(water_count * 0.10, 0.40)\n   654→\n   655→    def _cmd_cast(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n   656→        if not self.is_enabled(event.target):\n   657→            return False\n   658→\n   659→        user_id = self.bot.get_user_id(username)\n   660→        active_casts = self.get_state(\"active_casts\", {})\n   661→\n   662→        # Check if already has active cast\n   663→        if user_id in active_casts:\n   664→            cast = active_casts[user_id]\n   665→            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n   666→            elapsed = datetime.now(UTC) - cast_time\n   667→            hours = elapsed.total_seconds() / 3600\n   668→            self.safe_reply(\n   669→                connection, event,\n   670→                f\"{self.bot.title_for(username)}, you already have a line in the water at {cast['location']}! \"\n   671→                f\"It's been {hours:.1f} hours. Use !reel to bring it in.\"\n   672→            )\n   673→            return True\n   674→\n   675→        player = self._get_player(user_id)\n   676→        \n   677→        # Check if location argument was provided\n   678→        location_arg = match.group(1)\n   679→        if location_arg:\n   680→            # Try to find the requested location\n   681→            requested_location = self._find_location_by_name(location_arg)\n   682→            \n   683→            if not requested_location:\n   684→                # List all available locations\n   685→                available_locs = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n   686→                self.safe_reply(\n   687→                    connection, event,\n   688→                    f\"{self.bot.title_for(username)}, location '{location_arg}' not found. \"\n   689→                    f\"Available locations: {', '.join(available_locs)}\"\n   690→                )\n   691→                return True\n   692→            \n   693→            # Check if player has unlocked this location\n   694→            if requested_location[\"level\"] > player[\"level\"]:\n   695→                self.safe_reply(\n   696→                    connection, event,\n   697→                    f\"{self.bot.title_for(username)}, you haven't unlocked {requested_location['name']} yet! \"\n   698→                    f\"You need to be level {requested_location['level']} (currently level {player['level']}).\"\n   699→                )\n   700→                return True\n   701→            \n   702→            location = requested_location\n   703→        else:\n   704→            # No location specified, use current level's default location\n   705→            location = self._get_location_for_level(player[\"level\"])\n   706→        \n   707→        distance = self._get_cast_distance(player[\"level\"], location)\n   708→\n   709→        # Record the cast\n   710→        active_casts[user_id] = {\n   711→            \"timestamp\": datetime.now(UTC).isoformat(),\n   712→            \"distance\": distance,\n   713→            \"location\": location[\"name\"],\n   714→            \"channel\": event.target,\n   715→            \"allow_lower_fish\": not location_arg,\n   716→        }\n   717→        self.set_state(\"active_casts\", active_casts)\n   718→\n   719→        # Update player stats\n   720→        player[\"total_casts\"] += 1\n   721→        if distance > player[\"furthest_cast\"]:\n   722→            player[\"furthest_cast\"] = distance\n   723→        self._save_player(user_id, player)\n   724→\n   725→        # Check for event trigger\n   726→        triggered_event = self._check_event_trigger(event.target, location[\"name\"])\n   727→\n   728→        # Send cast message\n   729→        cast_msg = random.choice(CAST_MESSAGES).format(\n   730→            distance=distance,\n   731→            location=location[\"name\"]\n   732→        )\n   733→        self.safe_reply(connection, event, f\"{self.bot.title_for(username)}, {cast_msg}\")\n   734→\n   735→        # Announce event if triggered\n   736→        if triggered_event:\n   737→            self.safe_say(\n   738→                f\"** {triggered_event['name']} ** - {triggered_event['description']}\",\n   739→                target=event.target\n   740→            )\n   741→\n   742→        return True\n   743→\n   744→    def _cmd_reel(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n   745→        if not self.is_enabled(event.target):\n   746→            return False\n   747→\n   748→        user_id = self.bot.get_user_id(username)\n   749→        active_casts = self.get_state(\"active_casts\", {})\n   750→\n   751→        # Check if has active cast\n   752→        if user_id not in active_casts:\n   753→            self.safe_reply(\n   754→                connection, event,\n   755→                f\"{self.bot.title_for(username)}, you don't have a line in the water. Use !cast first.\"\n   756→            )\n   757→            return True\n   758→\n   759→        cast = active_casts[user_id]\n   760→        cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n   761→        now = datetime.now(UTC)\n   762→        elapsed = now - cast_time\n   763→        wait_hours = elapsed.total_seconds() / 3600\n   764→\n   765→        location_name = cast[\"location\"]\n   766→        location = next((l for l in LOCATIONS if l[\"name\"] == location_name), LOCATIONS[0])\n   767→        player = self._get_player(user_id)\n   768→        forced_rare_flag = player.get(\"force_rare_legendary\", False)\n   769→\n   770→        # Remove the cast\n   771→        del active_casts[user_id]\n   772→        self.set_state(\"active_casts\", active_casts)\n   773→        self.save_state()\n   774→\n   775→        # Get active event\n   776→        active_event = self._get_active_event(location_name)\n   777→\n   778→        # Apply time boost event if active\n   779→        effective_wait = wait_hours\n   780→        if active_event and active_event.get(\"effect\") == \"time_boost\":\n   781→            effective_wait = wait_hours / active_event.get(\"multiplier\", 1.0)\n   782→\n   783→        # Too early - nothing caught\n   784→        if effective_wait < self.MIN_WAIT_HOURS:\n   785→            self.safe_reply(connection, event, random.choice(TOO_EARLY_MESSAGES))\n   786→            return True\n   787→\n   788→        # Danger zone - chance of bad outcome\n   789→        if wait_hours > self.DANGER_THRESHOLD_HOURS and not forced_rare_flag:\n   790→            hours_over = wait_hours - self.DANGER_THRESHOLD_HOURS\n   791→            bad_chance = min(0.1 + (hours_over * 0.05), 0.9)\n   792→\n   793→            if random.random() < bad_chance:\n   794→                # Bad outcome\n   795→                bad_type = random.choice([\"line_break\", \"fish_escaped\", \"junk\"])\n   796→\n   797→                if bad_type == \"line_break\":\n   798→                    player[\"lines_broken\"] += 1\n   799→                    self._save_player(user_id, player)\n   800→                    achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n   801→                    self.safe_reply(\n   802→                        connection, event,\n   803→                        random.choice(DANGER_ZONE_MESSAGES[\"line_break\"])\n   804→                    )\n   805→                elif bad_type == \"fish_escaped\":\n   806→                    self.safe_reply(\n   807→                        connection, event,\n   808→                        random.choice(DANGER_ZONE_MESSAGES[\"fish_escaped\"])\n   809→                    )\n   810→                else:  # junk\n   811→                    junk = self._get_junk(location[\"type\"])\n   812→                    player[\"junk_collected\"] += 1\n   813→                    self._save_player(user_id, player)\n   814→                    achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n   815→                    self.safe_reply(\n   816→                        connection, event,\n   817→                        f\"After waiting {wait_hours:.1f} hours, you reel in... {junk}. \"\n   818→                        \"Maybe don't leave your line out so long next time.\"\n   819→                    )\n   820→                return True\n   821→\n   822→        # Junk check (base chance, boosted by murky waters)\n   823→        if not forced_rare_flag:\n   824→            junk_chance = 0.10\n   825→            if active_event and active_event.get(\"effect\") == \"junk_boost\":\n   826→                junk_chance *= active_event.get(\"multiplier\", 1.0)\n   827→\n   828→            if random.random() < junk_chance:\n   829→                junk = self._get_junk(location[\"type\"])\n   830→                player[\"junk_collected\"] += 1\n   831→                self._save_player(user_id, player)\n   832→                achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n   833→                xp_gain = 5  # Small XP for junk\n   834→                player[\"xp\"] += xp_gain\n   835→                self._save_player(user_id, player)\n   836→                self.safe_reply(\n   837→                    connection, event,\n   838→                    f\"{self.bot.title_for(username)} reels in... {junk}. \"\n   839→                    f\"Well, at least you're cleaning up! (+{xp_gain} XP)\"\n   840→                )\n   841→                return True\n   842→\n   843→        # Successful catch!\n   844→        water_boost = self._get_water_boost(player)\n   845→        rarity = self._select_rarity(effective_wait, active_event, water_boost)\n   846→        eligible_locations = None\n   847→        if cast.get(\"allow_lower_fish\"):\n   848→            eligible_locations = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n   849→        fish = None\n   850→        forced_rare = player.get(\"force_rare_legendary\", False)\n   851→        forced_rare_applied = False\n   852→        if forced_rare:\n   853→            forced_rarities = [\"rare\", \"legendary\"]\n   854→            random.shuffle(forced_rarities)\n   855→            for forced in forced_rarities:\n   856→                fish = self._select_fish(\n   857→                    location_name,\n   858→                    forced,\n   859→                    eligible_locations,\n   860→                    allow_fallback=False,\n   861→                )\n   862→                if fish:\n   863→                    rarity = forced\n   864→                    forced_rare_applied = True\n   865→                    break\n   866→\n   867→        if not fish:\n   868→            fish = self._select_fish(location_name, rarity, eligible_locations)\n   869→\n   870→        if not fish:\n   871→            # Fallback - shouldn't happen\n   872→            self.safe_reply(connection, event, \"The fish got away at the last moment!\")\n   873→            return True\n   874→\n   875→        weight = self._calculate_weight(fish, effective_wait)\n   876→\n   877→        # Line break check - bigger fish = higher chance\n   878→        if not forced_rare_applied:\n   879→            break_chance = 0.02 + (weight / 1000) * 0.15\n   880→            if random.random() < break_chance:\n   881→                player[\"lines_broken\"] += 1\n   882→                self._save_player(user_id, player)\n   883→                achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n   884→                self.safe_reply(\n   885→                    connection, event,\n   886→                    f\"You feel a massive tug - it's a {fish['name']}! But the weight is too much... \"\n   887→                    f\"SNAP! The line breaks! It got away...\"\n   888→                )\n   889→                return True\n   890→\n   891→        # Successful catch!\n   892→        player[\"total_fish\"] += 1\n   893→        if weight > player[\"biggest_fish\"]:\n   894→            player[\"biggest_fish\"] = weight\n   895→            player[\"biggest_fish_name\"] = fish[\"name\"]\n   896→\n   897→        if forced_rare_applied:\n   898→            player[\"force_rare_legendary\"] = False\n   899→\n   900→        # Track catches (global)\n   901→        catches = player.get(\"catches\", {})\n   902→        catches[fish[\"name\"]] = catches.get(fish[\"name\"], 0) + 1\n   903→        player[\"catches\"] = catches\n   904→\n   905→        # Track catches by location\n   906→        catches_by_location = player.get(\"catches_by_location\", {})\n   907→        if location_name not in catches_by_location:\n   908→            catches_by_location[location_name] = {}\n   909→        catches_by_location[location_name][fish[\"name\"]] = catches_by_location[location_name].get(fish[\"name\"], 0) + 1\n   910→        player[\"catches_by_location\"] = catches_by_location\n   911→\n   912→        # Track location\n   913→        if location_name not in player.get(\"locations_fished\", []):\n   914→            player.setdefault(\"locations_fished\", []).append(location_name)\n   915→\n   916→        # Track rare/legendary for aquarium\n   917→        if rarity in (\"rare\", \"legendary\"):\n   918→            rare_catches = player.get(\"rare_catches\", [])\n   919→            rare_catches.append({\n   920→                \"name\": fish[\"name\"],\n   921→                \"weight\": weight,\n   922→                \"rarity\": rarity,\n   923→                \"location\": location_name,\n   924→                \"caught_at\": now.isoformat(),\n   925→            })\n   926→            player[\"rare_catches\"] = rare_catches\n   927→\n   928→        # Calculate XP\n   929→        base_xp = 10\n   930→        rarity_mult = RARITY_XP_MULTIPLIER.get(rarity, 1)\n   931→        weight_bonus = 1 + (weight / 50)\n   932→        xp_gain = int(base_xp * rarity_mult * weight_bonus)\n   933→\n   934→        # Event XP boost\n   935→        if active_event and active_event.get(\"effect\") == \"xp_boost\":\n   936→            xp_gain = int(xp_gain * active_event.get(\"multiplier\", 1.0))\n   937→\n   938→        bonus_messages = []\n   939→        boost_catches = player.get(\"xp_boost_catches\", 0)\n   940→        if boost_catches > 0:\n   941→            xp_gain = int(xp_gain * XP_BOOST_MULTIPLIER)\n   942→            boost_catches -= 1\n   943→            player[\"xp_boost_catches\"] = boost_catches\n   944→            bonus_messages.append(f\"Rod boost! x{XP_BOOST_MULTIPLIER} XP.\")\n   945→            if boost_catches == 0:\n   946→                bonus_messages.append(\"The rod's glow fades.\")\n   947→\n   948→        extra_xp = 0\n   949→        roll = random.random()\n   950→        if roll < XP_BONUS_LARGE_CHANCE:\n   951→            extra_xp = random.randint(*XP_BONUS_LARGE_RANGE)\n   952→            bonus_messages.append(f\"Treasure haul! +{extra_xp} XP.\")\n   953→        elif roll < XP_BONUS_LARGE_CHANCE + XP_BONUS_SMALL_CHANCE:\n   954→            extra_xp = random.randint(*XP_BONUS_SMALL_RANGE)\n   955→            bonus_messages.append(f\"Lucky find! +{extra_xp} XP.\")\n   956→\n   957→        if player.get(\"xp_boost_catches\", 0) == 0 and random.random() < XP_BOOST_ROD_CHANCE:\n   958→            player[\"xp_boost_catches\"] = XP_BOOST_ROD_CATCHES\n   959→            bonus_messages.append(\n   960→                f\"You found a better rod! Next {XP_BOOST_ROD_CATCHES} catches give double XP.\"\n   961→            )\n   962→\n   963→        total_xp = xp_gain + extra_xp\n   964→        player[\"xp\"] += total_xp\n   965→        self._save_player(user_id, player)\n   966→\n   967→        # Record achievements\n   968→        achievement_hooks.record_achievement(self.bot, username, \"fish_caught\", 1)\n   969→        if rarity == \"rare\":\n   970→            achievement_hooks.record_achievement(self.bot, username, \"rare_fish_caught\", 1)\n   971→        elif rarity == \"legendary\":\n   972→            achievement_hooks.record_achievement(self.bot, username, \"legendary_fish_caught\", 1)\n   973→\n   974→        # Perfect wait achievement (18-24 hours)\n   975→        if 18.0 <= wait_hours <= 24.0:\n   976→            achievement_hooks.record_achievement(self.bot, username, \"perfect_waits\", 1)\n   977→\n   978→        # Check level up\n   979→        new_level = self._check_level_up(user_id, player, username)\n   980→\n   981→        # Build response\n   982→        rarity_prefix = \"\"\n   983→        if rarity == \"uncommon\":\n   984→            rarity_prefix = \"an uncommon \"\n   985→        elif rarity == \"rare\":\n   986→            rarity_prefix = \"a RARE \"\n   987→        elif rarity == \"legendary\":\n   988→            rarity_prefix = \"a LEGENDARY \"\n   989→        else:\n   990→            rarity_prefix = \"a \"\n   991→\n   992→        response = (\n   993→            f\"{self.bot.title_for(username)} reels in {rarity_prefix}{fish['name']} \"\n   994→            f\"weighing {weight:.2f} lbs after waiting {wait_hours:.1f} hours! (+{total_xp} XP)\"\n   995→        )\n   996→        if bonus_messages:\n   997→            response += \" \" + \" \".join(bonus_messages)\n   998→        if forced_rare_applied:\n   999→            response += \" A rare blessing guides your catch.\"\n  1000→\n  1001→        if new_level:\n  1002→            new_location = self._get_location_for_level(new_level)\n  1003→            response += f\" LEVEL UP! You're now level {new_level} and can fish at {new_location['name']}!\"\n  1004→\n  1005→        self.safe_reply(connection, event, response)\n  1006→        return True\n  1007→\n  1008→    def _cmd_fishing_bless(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1009→        if not self.is_enabled(event.target):\n  1010→            return False\n  1011→\n  1012→        target = match.group(1).strip()\n  1013→        target_id = self.bot.get_user_id(target)\n  1014→        player = self._get_player(target_id)\n  1015→        player[\"force_rare_legendary\"] = True\n  1016→        self._save_player(target_id, player)\n  1017→\n  1018→        self.safe_reply(\n  1019→            connection,\n  1020→            event,\n  1021→            f\"{self.bot.title_for(target)}, your next catch will be rare or legendary.\"\n  1022→        )\n  1023→        return True\n  1024→\n  1025→    def _cmd_fishing_stats(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1026→        if not self.is_enabled(event.target):\n  1027→            return False\n  1028→\n  1029→        user_id = self.bot.get_user_id(username)\n  1030→        player = self._get_player(user_id)\n  1031→        location = self._get_location_for_level(player[\"level\"])\n  1032→\n  1033→        xp_needed = self._get_xp_for_level(player[\"level\"])\n  1034→        xp_progress = f\"{player['xp']}/{xp_needed}\"\n  1035→\n  1036→        stats = (\n  1037→            f\"Fishing Stats for {self.bot.title_for(username)}: \"\n  1038→            f\"Level {player['level']} ({location['name']}) | \"\n  1039→            f\"XP: {xp_progress} | \"\n  1040→            f\"Fish: {player['total_fish']} | \"\n  1041→            f\"Biggest: {player['biggest_fish']:.2f} lbs\"\n  1042→        )\n  1043→\n  1044→        if player.get(\"biggest_fish_name\"):\n  1045→            stats += f\" ({player['biggest_fish_name']})\"\n  1046→\n  1047→        stats += f\" | Casts: {player['total_casts']} | Junk: {player['junk_collected']}\"\n  1048→\n  1049→        self.safe_reply(connection, event, stats)\n  1050→        return True\n  1051→\n  1052→    def _cmd_fishing_top(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1053→        if not self.is_enabled(event.target):\n  1054→            return False\n  1055→\n  1056→        players = self.get_state(\"players\", {})\n  1057→        if not players:\n  1058→            self.safe_reply(connection, event, \"No one has gone fishing yet!\")\n  1059→            return True\n  1060→\n  1061→        # Get user map for display names\n  1062→        user_map = self.bot.get_module_state(\"users\").get(\"user_map\", {})\n  1063→\n  1064→        # Top by total fish\n  1065→        by_fish = sorted(\n  1066→            [(uid, p) for uid, p in players.items() if p.get(\"total_fish\", 0) > 0],\n  1067→            key=lambda x: x[1][\"total_fish\"],\n  1068→            reverse=True\n  1069→        )[:5]\n  1070→\n  1071→        # Top by biggest fish\n  1072→        by_size = sorted(\n  1073→            [(uid, p) for uid, p in players.items() if p.get(\"biggest_fish\", 0) > 0],\n  1074→            key=lambda x: x[1][\"biggest_fish\"],\n  1075→            reverse=True\n  1076→        )[:5]\n  1077→\n  1078→        response_parts = [\"Fishing Leaderboards:\"]\n  1079→\n  1080→        if by_fish:\n  1081→            fish_list = []\n  1082→            for i, (uid, p) in enumerate(by_fish):\n  1083→                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n  1084→                fish_list.append(f\"#{i+1} {name} ({p['total_fish']})\")\n  1085→            response_parts.append(\"Most Fish: \" + \", \".join(fish_list))\n  1086→\n  1087→        if by_size:\n  1088→            size_list = []\n  1089→            for i, (uid, p) in enumerate(by_size):\n  1090→                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n  1091→                fish_name = p.get(\"biggest_fish_name\", \"fish\")\n  1092→                size_list.append(f\"#{i+1} {name} ({p['biggest_fish']:.1f} lbs - {fish_name})\")\n  1093→            response_parts.append(\"Biggest Catch: \" + \", \".join(size_list))\n  1094→\n  1095→        self.safe_reply(connection, event, \" | \".join(response_parts))\n  1096→        return True\n  1097→\n  1098→    def _cmd_fishing_location(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1099→        if not self.is_enabled(event.target):\n  1100→            return False\n  1101→\n  1102→        user_id = self.bot.get_user_id(username)\n  1103→        player = self._get_player(user_id)\n  1104→        current_loc = self._get_location_for_level(player[\"level\"])\n  1105→\n  1106→        # Check for active cast\n  1107→        active_casts = self.get_state(\"active_casts\", {})\n  1108→        if user_id in active_casts:\n  1109→            cast = active_casts[user_id]\n  1110→            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n  1111→            elapsed = datetime.now(UTC) - cast_time\n  1112→            hours = elapsed.total_seconds() / 3600\n  1113→            self.safe_reply(\n  1114→                connection, event,\n  1115→                f\"{self.bot.title_for(username)}: Currently fishing at {cast['location']} \"\n  1116→                f\"(line out for {hours:.1f} hours). Level {player['level']}.\"\n  1117→            )\n  1118→            return True\n  1119→\n  1120→        # Build location progress\n  1121→        unlocked = [l for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n  1122→        next_loc = next((l for l in LOCATIONS if l[\"level\"] > player[\"level\"]), None)\n  1123→\n  1124→        response = (\n  1125→            f\"{self.bot.title_for(username)}: Level {player['level']}, \"\n  1126→            f\"currently at {current_loc['name']}. \"\n  1127→            f\"Unlocked: {', '.join(l['name'] for l in unlocked)}.\"\n  1128→        )\n  1129→\n  1130→        if next_loc:\n  1131→            xp_needed = self._get_xp_for_level(player[\"level\"])\n  1132→            response += f\" Next: {next_loc['name']} at level {next_loc['level']} ({player['xp']}/{xp_needed} XP).\"\n  1133→\n  1134→        self.safe_reply(connection, event, response)\n  1135→        return True\n  1136→\n  1137→    def _cmd_aquarium(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1138→        if not self.is_enabled(event.target):\n  1139→            return False\n  1140→\n  1141→        user_id = self.bot.get_user_id(username)\n  1142→        player = self._get_player(user_id)\n  1143→        rare_catches = player.get(\"rare_catches\", [])\n  1144→\n  1145→        if not rare_catches:\n  1146→            self.safe_reply(\n  1147→                connection, event,\n  1148→                f\"{self.bot.title_for(username)}'s aquarium is empty. \"\n  1149→                \"Catch some rare or legendary fish to display them here!\"\n  1150→            )\n  1151→            return True\n  1152→\n  1153→        # Group by rarity\n  1154→        legendaries = [c for c in rare_catches if c[\"rarity\"] == \"legendary\"]\n  1155→        rares = [c for c in rare_catches if c[\"rarity\"] == \"rare\"]\n  1156→\n  1157→        response_parts = [f\"{self.bot.title_for(username)}'s Aquarium:\"]\n  1158→\n  1159→        if legendaries:\n  1160→            leg_display = \", \".join(\n  1161→                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n  1162→                for c in legendaries[-5:]  # Last 5\n  1163→            )\n  1164→            response_parts.append(f\"LEGENDARY: {leg_display}\")\n  1165→\n  1166→        if rares:\n  1167→            rare_display = \", \".join(\n  1168→                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n  1169→                for c in rares[-5:]  # Last 5\n  1170→            )\n  1171→            response_parts.append(f\"Rare: {rare_display}\")\n  1172→\n  1173→        self.safe_reply(connection, event, \" | \".join(response_parts))\n  1174→        return True\n  1175→\n  1176→    def _cmd_fishinfo(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1177→        if not self.is_enabled(event.target):\n  1178→            return False\n  1179→\n  1180→        user_id = self.bot.get_user_id(username)\n  1181→        player = self._get_player(user_id)\n  1182→        \n  1183→        # Get location argument\n  1184→        location_arg = match.group(1)\n  1185→        \n  1186→        if not location_arg:\n  1187→            # No location specified - show available locations\n  1188→            locations_fished = player.get(\"locations_fished\", [])\n  1189→            if not locations_fished:\n  1190→                self.safe_reply(\n  1191→                    connection, event,\n  1192→                    f\"{self.bot.title_for(username)}, you haven't caught any fish yet! \"\n  1193→                    \"Use !cast and !reel to start fishing.\"\n  1194→                )\n  1195→                return True\n  1196→            \n  1197→            self.safe_reply(\n  1198→                connection, event,\n  1199→                f\"{self.bot.title_for(username)}, locations you've fished: {', '.join(locations_fished)}. \"\n  1200→                \"Use !fishinfo <location> to see fish caught there.\"\n  1201→            )\n  1202→            return True\n  1203→        \n  1204→        # Find the location\n  1205→        location = self._find_location_by_name(location_arg)\n  1206→        if not location:\n  1207→            self.safe_reply(\n  1208→                connection, event,\n  1209→                f\"{self.bot.title_for(username)}, location '{location_arg}' not found.\"\n  1210→            )\n  1211→            return True\n  1212→        \n  1213→        location_name = location[\"name\"]\n  1214→        \n  1215→        # Get catches for this location\n  1216→        catches_by_location = player.get(\"catches_by_location\", {})\n  1217→        location_catches = catches_by_location.get(location_name, {})\n  1218→        \n  1219→        if not location_catches:\n  1220→            self.safe_reply(\n  1221→                connection, event,\n  1222→                f\"{self.bot.title_for(username)}, you haven't caught any fish at {location_name} yet!\"\n  1223→            )\n  1224→            return True\n  1225→        \n  1226→        # Get all fish available at this location for completion stats\n  1227→        all_fish = FISH_DATABASE.get(location_name, [])\n  1228→        total_species = len(all_fish)\n  1229→        caught_species = len(location_catches)\n  1230→        \n  1231→        # Group by rarity\n  1232→        caught_by_rarity = {\"common\": [], \"uncommon\": [], \"rare\": [], \"legendary\": []}\n  1233→        for fish_name, count in location_catches.items():\n  1234→            # Find the fish in the database to get its rarity\n  1235→            fish_data = next((f for f in all_fish if f[\"name\"] == fish_name), None)\n  1236→            if fish_data:\n  1237→                rarity = fish_data[\"rarity\"]\n  1238→                caught_by_rarity[rarity].append(f\"{fish_name} ({count})\")\n  1239→        \n  1240→        # Build response\n  1241→        total_caught = sum(location_catches.values())\n  1242→        response_parts = [\n  1243→            f\"{self.bot.title_for(username)}'s {location_name} catches: \"\n  1244→            f\"{total_caught} fish, {caught_species}/{total_species} species\"\n  1245→        ]\n  1246→        \n  1247→        # Add fish by rarity\n  1248→        for rarity in [\"legendary\", \"rare\", \"uncommon\", \"common\"]:\n  1249→            if caught_by_rarity[rarity]:\n  1250→                rarity_label = rarity.upper() if rarity in [\"legendary\", \"rare\"] else rarity.capitalize()\n  1251→                fish_list = \", \".join(caught_by_rarity[rarity])\n  1252→                response_parts.append(f\"{rarity_label}: {fish_list}\")\n  1253→        \n  1254→        # Send as multiple messages if too long\n  1255→        full_response = \" | \".join(response_parts)\n  1256→        if len(full_response) > 400:\n  1257→            # Send in parts\n  1258→            self.safe_reply(connection, event, response_parts[0])\n  1259→            for part in response_parts[1:]:\n  1260→                self.safe_say(part, target=event.target)\n  1261→        else:\n  1262→            self.safe_reply(connection, event, full_response)\n  1263→        \n  1264→        return True\n  1265→\n  1266→    def _cmd_fishing_help(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1267→        if not self.is_enabled(event.target):\n  1268→            return False\n  1269→\n  1270→        help_lines = [\n  1271→            \"Fishing Commands:\",\n  1272→            \"!cast - Cast at your current level (can catch fish from any unlocked lower levels)\",\n  1273→            \"!cast <location> - Cast at a specific unlocked location (e.g., !cast pond)\",\n  1274→            \"!reel - Reel in your catch (wait 1-24 hours for best results)\",\n  1275→            \"!fishing - Show your stats\",\n  1276→            \"!fishing top - Leaderboards\",\n  1277→            \"!fishing location - Current location and level progress\",\n  1278→            \"!fishinfo - List locations you've fished\",\n  1279→            \"!fishinfo <location> - Show fish caught at a specific location (e.g., !fishinfo pond)\",\n  1280→            \"!aquarium - View your rare/legendary catches\",\n  1281→            \"!water - Celebrate finishing a water bottle (boosts rare fish, max 4/day)\",\n  1282→            \"\",\n  1283→            \"Tips: !cast pulls fish from your current level and any lower unlocked levels.\",\n  1284→            \"You can also travel back to previous locations to hunt for rare fish you missed!\",\n  1285→            \"Stay hydrated! Each bottle of water increases rare fish chances by 10% (up to 40%).\",\n  1286→        ]\n  1287→\n  1288→        for line in help_lines:\n  1289→            self.safe_privmsg(username, line)\n  1290→\n  1291→        self.safe_reply(\n  1292→            connection, event,\n  1293→            f\"{self.bot.title_for(username)}, I've sent you the fishing guide.\"\n  1294→        )\n  1295→        return True\n  1296→\n  1297→    def _cmd_water(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n  1298→        if not self.is_enabled(event.target):\n  1299→            return False\n  1300→\n  1301→        user_id = self.bot.get_user_id(username)\n  1302→        player = self._get_player(user_id)\n  1303→\n  1304→        # Get today's date\n  1305→        today = datetime.now(UTC).date().isoformat()\n  1306→        water_date = player.get(\"water_date\")\n  1307→        water_count = player.get(\"water_today\", 0)\n  1308→\n  1309→        # Reset counter if it's a new day\n  1310→        if water_date != today:\n  1311→            water_count = 0\n  1312→            water_date = today\n  1313→\n  1314→        # Check if they've already had 4 bottles today\n  1315→        if water_count >= 4:\n  1316→            self.safe_reply(\n  1317→                connection, event,\n  1318→                f\"{self.bot.title_for(username)}, you have already consumed your four bottles of water today! \"\n  1319→                \"Most commendable dedication to hydration. Do return tomorrow for further encouragement.\"\n  1320→            )\n  1321→            return True\n  1322→\n  1323→        # Increment the counter\n  1324→        water_count += 1\n  1325→        player[\"water_today\"] = water_count\n  1326→        player[\"water_date\"] = today\n  1327→        self._save_player(user_id, player)\n  1328→\n  1329→        # Calculate new boost percentage\n  1330→        boost_percentage = water_count * 10\n  1331→\n  1332→        # Build response based on how many they've had\n  1333→        if water_count == 1:\n  1334→            response = (\n  1335→                f\"Splendid! {self.bot.title_for(username)}, I am delighted to see you tending to your hydration. \"\n  1336→                f\"Three more bottles to go! Your commitment to wellness grants you a {boost_percentage}% boost \"\n  1337→                \"to catching rare and legendary fish today.\"\n  1338→            )\n  1339→        elif water_count == 2:\n  1340→            response = (\n  1341→                f\"Excellent progress, {self.bot.title_for(username)}! Two bottles down, two more to go! \"\n  1342→                f\"Your dedication is most admirable. You now have a {boost_percentage}% boost to rare catches.\"\n  1343→            )\n  1344→        elif water_count == 3:\n  1345→            response = (\n  1346→                f\"Marvelous! {self.bot.title_for(username)}, just one more bottle remains! \"\n  1347→                f\"You are nearly at peak hydration. Current boost: {boost_percentage}% to rare and legendary fish.\"\n  1348→            )\n  1349→        else:  # water_count == 4\n  1350→            response = (\n  1351→                f\"Outstanding! {self.bot.title_for(username)}, you have completed your daily hydration goal! \"\n  1352→                f\"I am exceedingly proud of your commitment to health. You now enjoy a magnificent {boost_percentage}% \"\n  1353→                \"boost to catching rare and legendary fish for the remainder of the day!\"\n  1354→            )\n  1355→\n  1356→        self.safe_reply(connection, event, response)\n  1357→        return True\n  1358→"}]},"uuid":"96118f94-e28b-41d0-9933-94417a6d1e58","timestamp":"2026-02-12T01:13:32.041Z","toolUseResult":{"type":"text","file":{"filePath":"/home/nylan/code/jeeves/modules/fishing.py","content":"# modules/fishing.py\n# A fishing mini-game where users cast lines and reel in catches over time.\n\nimport random\nimport re\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom .base import SimpleCommandModule\nfrom . import achievement_hooks\n\nUTC = timezone.utc\n\n\ndef setup(bot: Any) -> 'Fishing':\n    return Fishing(bot)\n\n\n# Fishing locations unlocked by level (0-9)\nLOCATIONS = [\n    {\"name\": \"Puddle\", \"level\": 0, \"max_distance\": 5, \"type\": \"terrestrial\"},\n    {\"name\": \"Pond\", \"level\": 1, \"max_distance\": 15, \"type\": \"terrestrial\"},\n    {\"name\": \"Lake\", \"level\": 2, \"max_distance\": 30, \"type\": \"terrestrial\"},\n    {\"name\": \"River\", \"level\": 3, \"max_distance\": 50, \"type\": \"terrestrial\"},\n    {\"name\": \"Ocean\", \"level\": 4, \"max_distance\": 100, \"type\": \"terrestrial\"},\n    {\"name\": \"Deep Sea\", \"level\": 5, \"max_distance\": 200, \"type\": \"terrestrial\"},\n    {\"name\": \"Moon\", \"level\": 6, \"max_distance\": 500, \"type\": \"space\"},\n    {\"name\": \"Mars\", \"level\": 7, \"max_distance\": 1000, \"type\": \"space\"},\n    {\"name\": \"Jupiter\", \"level\": 8, \"max_distance\": 2000, \"type\": \"space\"},\n    {\"name\": \"The Void\", \"level\": 9, \"max_distance\": 5000, \"type\": \"space\"},\n]\n\n# Fish database organized by location\n# Each fish has: name, min_weight, max_weight, rarity\nFISH_DATABASE: Dict[str, List[Dict[str, Any]]] = {\n    \"Puddle\": [\n        # Common\n        {\"name\": \"Minnow\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        {\"name\": \"Tadpole\", \"min_weight\": 0.05, \"max_weight\": 0.2, \"rarity\": \"common\"},\n        {\"name\": \"Guppy\", \"min_weight\": 0.1, \"max_weight\": 0.3, \"rarity\": \"common\"},\n        {\"name\": \"Water Beetle\", \"min_weight\": 0.01, \"max_weight\": 0.1, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Goldfish\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Small Frog\", \"min_weight\": 0.3, \"max_weight\": 1.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Koi\", \"min_weight\": 2.0, \"max_weight\": 5.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Puddle King\", \"min_weight\": 8.0, \"max_weight\": 15.0, \"rarity\": \"legendary\"},\n    ],\n    \"Pond\": [\n        # Common\n        {\"name\": \"Bluegill\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Perch\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Sunfish\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Crayfish\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Largemouth Bass\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Catfish\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Perch\", \"min_weight\": 5.0, \"max_weight\": 12.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Old Whiskers\", \"min_weight\": 20.0, \"max_weight\": 40.0, \"rarity\": \"legendary\"},\n    ],\n    \"Lake\": [\n        # Common\n        {\"name\": \"Trout\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Crappie\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Walleye\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Pike\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Lake Sturgeon\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Muskie\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Albino Sturgeon\", \"min_weight\": 20.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Nessie's Cousin\", \"min_weight\": 100.0, \"max_weight\": 200.0, \"rarity\": \"legendary\"},\n    ],\n    \"River\": [\n        # Common\n        {\"name\": \"Salmon\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Steelhead\", \"min_weight\": 4.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        {\"name\": \"River Carp\", \"min_weight\": 3.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Smallmouth Bass\", \"min_weight\": 2.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"King Salmon\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Paddlefish\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Salmon\", \"min_weight\": 25.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The River Guardian\", \"min_weight\": 80.0, \"max_weight\": 150.0, \"rarity\": \"legendary\"},\n    ],\n    \"Ocean\": [\n        # Common\n        {\"name\": \"Tuna\", \"min_weight\": 20.0, \"max_weight\": 80.0, \"rarity\": \"common\"},\n        {\"name\": \"Mackerel\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Sea Bass\", \"min_weight\": 10.0, \"max_weight\": 40.0, \"rarity\": \"common\"},\n        {\"name\": \"Flounder\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Swordfish\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Mahi-Mahi\", \"min_weight\": 15.0, \"max_weight\": 50.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Barracuda\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Blue Marlin\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Sailfish\", \"min_weight\": 80.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Moby Dick Jr.\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Deep Sea\": [\n        # Common\n        {\"name\": \"Anglerfish\", \"min_weight\": 5.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Viperfish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Gulper Eel\", \"min_weight\": 3.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Lanternfish\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Giant Squid\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Oarfish\", \"min_weight\": 30.0, \"max_weight\": 100.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Goblin Shark\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Colossal Squid\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Megamouth Shark\", \"min_weight\": 300.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Kraken\", \"min_weight\": 1000.0, \"max_weight\": 2500.0, \"rarity\": \"legendary\"},\n    ],\n    \"Moon\": [\n        # Common\n        {\"name\": \"Moon Jellyfish\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Lunar Shrimp\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Crater Minnow\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Dust Swimmer\", \"min_weight\": 1.0, \"max_weight\": 4.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Crater Crab\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Void Eel\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Selenite Fish\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Cosmic Whale\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        {\"name\": \"Starlight Serpent\", \"min_weight\": 40.0, \"max_weight\": 150.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Leviathan of Tranquility\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Mars\": [\n        # Common\n        {\"name\": \"Rust Minnow\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Red Silt Crawler\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Iron Guppy\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Dust Devil Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Olympus Bass\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Valles Trout\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Phobos Flounder\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Martian Kraken\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Red Planet Leviathan\", \"min_weight\": 150.0, \"max_weight\": 400.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Ancient One\", \"min_weight\": 1000.0, \"max_weight\": 2000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Jupiter\": [\n        # Common\n        {\"name\": \"Gas Giant Jellyfish\", \"min_weight\": 2.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Storm Swimmer\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Ammonia Minnow\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Cloud Drifter\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Red Spot Ray\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Ammonia Eel\", \"min_weight\": 30.0, \"max_weight\": 80.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Io Salmon\", \"min_weight\": 25.0, \"max_weight\": 70.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Jovian Leviathan\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Europa Ice Beast\", \"min_weight\": 250.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Great Red Serpent\", \"min_weight\": 2000.0, \"max_weight\": 4000.0, \"rarity\": \"legendary\"},\n    ],\n    \"The Void\": [\n        # Common\n        {\"name\": \"Void Mite\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Dark Matter Shrimp\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Null Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Entropy Minnow\", \"min_weight\": 1.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Entropy Eel\", \"min_weight\": 25.0, \"max_weight\": 75.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Singularity Squid\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Dimensional Drifter\", \"min_weight\": 40.0, \"max_weight\": 120.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Reality Warper\", \"min_weight\": 300.0, \"max_weight\": 800.0, \"rarity\": \"rare\"},\n        {\"name\": \"Event Horizon Eel\", \"min_weight\": 400.0, \"max_weight\": 900.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Cosmic Horror\", \"min_weight\": 5000.0, \"max_weight\": 10000.0, \"rarity\": \"legendary\"},\n        {\"name\": \"Cthulhu's Cousin\", \"min_weight\": 8000.0, \"max_weight\": 15000.0, \"rarity\": \"legendary\"},\n    ],\n}\n\n# Junk items by location type\nJUNK_ITEMS: Dict[str, List[str]] = {\n    \"terrestrial\": [\n        \"Old Boot\", \"Rusty Tin Can\", \"Soggy Newspaper\", \"Tangled Fishing Line\",\n        \"Broken Sunglasses\", \"Waterlogged Book\", \"Deflated Beach Ball\", \"Lost Flip-Flop\",\n        \"Shopping Cart Wheel\", \"Plastic Bottle\", \"Tire\", \"Underwear\", \"License Plate\",\n        \"Broken Umbrella\", \"Moldy Wallet\", \"Damp Cigarette Pack\", \"Fishing Bobber\",\n        \"Knitting Needle\", \"Crochet Hook\", \"Tangled Yarn Ball\", \"Stitch Marker\",\n        \"Frayed Crochet Bag\", \"Half-Finished Scarf\", \"Pattern Printout\",\n        \"Game Controller\", \"Pixelated Cartridge\", \"Arcade Token\", \"Headset Mic\",\n        \"Trophy Cup\", \"Resistance Band\", \"Kettlebell\", \"Gym Towel\",\n        \"Protein Shaker\", \"Yoga Mat\", \"Jump Rope\",\n    ],\n    \"space\": [\n        \"Space Debris\", \"Frozen Oxygen Chunk\", \"Abandoned Satellite\", \"Lost Astronaut Glove\",\n        \"Alien Artifact\", \"Meteor Fragment\", \"Cosmic Dust Bunny\", \"Derelict Probe\",\n        \"Ancient Star Map\", \"Fossilized Moonrock\", \"Mysterious Orb\", \"Quantum Fluctuation\",\n        \"Void Crystal\", \"Broken Warp Core\", \"Lost Space Buoy\", \"Crystallized Stardust\",\n        \"Zero-G Yarn Ball\", \"Starlight Crochet Hook\", \"Orbital Knitting Needle\",\n        \"Cosmic Game Controller\", \"Nebula Cartridge\", \"Warped Arcade Token\",\n        \"Anti-Gravity Kettlebell\", \"Meteorite Dumbbell\", \"Vacuum-Sealed Gym Towel\",\n        \"Protein Paste Packet\", \"Quantum Jump Rope\",\n    ],\n}\n\n# Random events that can trigger\nEVENTS: Dict[str, Dict[str, Any]] = {\n    \"full_moon\": {\n        \"name\": \"Full Moon\",\n        \"description\": \"The full moon rises! Rare fish are more active.\",\n        \"effect\": \"rare_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 30,\n    },\n    \"solar_flare\": {\n        \"name\": \"Solar Flare\",\n        \"description\": \"A solar flare energizes the waters! Double XP!\",\n        \"effect\": \"xp_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n    \"feeding_frenzy\": {\n        \"name\": \"Feeding Frenzy\",\n        \"description\": \"The fish are hungry! Catches are easier.\",\n        \"effect\": \"time_boost\",\n        \"multiplier\": 0.5,  # Halves effective required time\n        \"duration_minutes\": 25,\n    },\n    \"murky_waters\": {\n        \"name\": \"Murky Waters\",\n        \"description\": \"The waters are murky... more junk than usual.\",\n        \"effect\": \"junk_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 15,\n    },\n    \"meteor_shower\": {\n        \"name\": \"Meteor Shower\",\n        \"description\": \"A meteor shower brings strange creatures from beyond!\",\n        \"effect\": \"alien_fish\",\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n}\n\n# Rarity weights for fish selection\nRARITY_WEIGHTS = {\n    \"common\": 70,\n    \"uncommon\": 20,\n    \"rare\": 8,\n    \"legendary\": 2,\n}\n\n# XP multipliers by rarity\nRARITY_XP_MULTIPLIER = {\n    \"common\": 1,\n    \"uncommon\": 2,\n    \"rare\": 5,\n    \"legendary\": 20,\n}\n\n# XP bonus chances (per successful catch)\nXP_BONUS_SMALL_CHANCE = 0.04\nXP_BONUS_LARGE_CHANCE = 0.01\nXP_BOOST_ROD_CHANCE = 0.007\nXP_BOOST_ROD_CATCHES = 5\nXP_BOOST_MULTIPLIER = 2\nXP_BONUS_SMALL_RANGE = (8, 20)\nXP_BONUS_LARGE_RANGE = (40, 90)\n\n# Cast flavor messages\nCAST_MESSAGES = [\n    \"You cast your line, it goes {distance}m and floats quietly...\",\n    \"With a practiced flick, your line sails {distance}m into the {location}.\",\n    \"Your line arcs gracefully, landing {distance}m away in the {location}.\",\n    \"The line whips through the air, settling {distance}m out.\",\n    \"You send your line sailing {distance}m. Now we wait...\",\n]\n\n# Reel too early messages\nTOO_EARLY_MESSAGES = [\n    \"You reel in too soon - the line is empty. Perhaps patience is a virtue?\",\n    \"Nothing but an empty hook. The fish need more time to find your bait.\",\n    \"Your line comes back bare. Try waiting a bit longer next time.\",\n    \"Too hasty! The fish haven't even noticed your bait yet.\",\n    \"An empty catch. Good things come to those who wait.\",\n]\n\n# Danger zone messages (over 24 hours)\nDANGER_ZONE_MESSAGES = {\n    \"line_break\": [\n        \"The line finally snaps from the strain! It was out there too long.\",\n        \"Your line, weakened by time, breaks as you try to reel in.\",\n        \"The elements have taken their toll - your line breaks clean off!\",\n    ],\n    \"fish_escaped\": [\n        \"The fish got tired of waiting and swam away ages ago.\",\n        \"Whatever was on the line has long since escaped.\",\n        \"You reel in... nothing. The fish left hours ago.\",\n    ],\n    \"junk\": [\n        \"After all that time, you only catch some waterlogged junk.\",\n        \"The long wait rewards you with... garbage. How fitting.\",\n    ],\n}\n\n\nclass Fishing(SimpleCommandModule):\n    name = \"fishing\"\n    version = \"1.0.0\"\n    description = \"A fishing mini-game with locations, leveling, and rare catches.\"\n\n    # Time thresholds in hours\n    MIN_WAIT_HOURS = 1.0\n    OPTIMAL_WAIT_HOURS = 24.0\n    DANGER_THRESHOLD_HOURS = 24.0\n    MAX_DANGER_HOURS = 48.0\n\n    def __init__(self, bot: Any) -> None:\n        super().__init__(bot)\n\n        # Initialize state\n        if not self.get_state(\"active_casts\"):\n            self.set_state(\"active_casts\", {})\n        if not self.get_state(\"players\"):\n            self.set_state(\"players\", {})\n        if not self.get_state(\"active_event\"):\n            self.set_state(\"active_event\", None)\n        self.save_state()\n\n    def _register_commands(self) -> None:\n        self.register_command(\n            r'^\\s*!cast(?:\\s+(.+))?\\s*$',\n            self._cmd_cast,\n            name=\"cast\",\n            description=\"Cast your fishing line (optionally specify location)\"\n        )\n        self.register_command(\n            r'^\\s*!reel\\s*$',\n            self._cmd_reel,\n            name=\"reel\",\n            description=\"Reel in your catch\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing|stats)?\\s*$',\n            self._cmd_fishing_stats,\n            name=\"fishing\",\n            description=\"Show your fishing statistics\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+top\\s*$',\n            self._cmd_fishing_top,\n            name=\"fishing top\",\n            description=\"Show fishing leaderboards\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+location\\s*$',\n            self._cmd_fishing_location,\n            name=\"fishing location\",\n            description=\"Show your current fishing location\"\n        )\n        self.register_command(\n            r'^\\s*!fishinfo(?:\\s+(.+))?\\s*$',\n            self._cmd_fishinfo,\n            name=\"fishinfo\",\n            description=\"Show fish caught in a specific location\"\n        )\n        self.register_command(\n            r'^\\s*!aquarium\\s*$',\n            self._cmd_aquarium,\n            name=\"aquarium\",\n            description=\"Show your rare and legendary catches\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+help\\s*$',\n            self._cmd_fishing_help,\n            name=\"fishing help\",\n            description=\"Show fishing help\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+bless\\s+(\\S+)\\s*$',\n            self._cmd_fishing_bless,\n            name=\"fishing bless\",\n            admin_only=True,\n            description=\"[Admin] Guarantee a user's next catch is rare or legendary\"\n        )\n        self.register_command(\n            r'^\\s*!water\\s*$',\n            self._cmd_water,\n            name=\"water\",\n            description=\"Celebrate finishing a water bottle (boosts rare fish chances)\"\n        )\n\n    def _get_player(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Get or create a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        if user_id not in players:\n            players[user_id] = {\n                \"level\": 0,\n                \"xp\": 0,\n                \"total_fish\": 0,\n                \"biggest_fish\": 0.0,\n                \"biggest_fish_name\": None,\n                \"total_casts\": 0,\n                \"furthest_cast\": 0.0,\n                \"lines_broken\": 0,\n                \"junk_collected\": 0,\n                \"catches\": {},\n                \"catches_by_location\": {},  # {\"location_name\": {\"fish_name\": count}}\n                \"rare_catches\": [],\n                \"locations_fished\": [],\n                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"xp_boost_catches\": 0,\n                \"force_rare_legendary\": False,\n            }\n            self.set_state(\"players\", players)\n            self.save_state()\n        return players[user_id]\n\n    def _save_player(self, user_id: str, player: Dict[str, Any]) -> None:\n        \"\"\"Save a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        players[user_id] = player\n        self.set_state(\"players\", players)\n        self.save_state()\n\n    def _get_location_for_level(self, level: int) -> Dict[str, Any]:\n        \"\"\"Get the location a player can fish at based on their level.\"\"\"\n        # Player fishes at their max unlocked location\n        for loc in reversed(LOCATIONS):\n            if loc[\"level\"] <= level:\n                return loc\n        return LOCATIONS[0]\n\n    def _find_location_by_name(self, location_query: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Find a location by name (case-insensitive, supports partial matches).\"\"\"\n        query = location_query.strip().lower()\n        \n        # Try exact match first\n        for loc in LOCATIONS:\n            if loc[\"name\"].lower() == query:\n                return loc\n        \n        # Try partial match\n        for loc in LOCATIONS:\n            if query in loc[\"name\"].lower():\n                return loc\n        \n        return None\n\n    def _get_xp_for_level(self, level: int) -> int:\n        \"\"\"Calculate XP needed for a level.\"\"\"\n        return int(100 * ((level + 1) ** 1.5))\n\n    def _check_level_up(self, user_id: str, player: Dict[str, Any], username: str) -> Optional[int]:\n        \"\"\"Check if player leveled up, return new level if so.\"\"\"\n        current_level = player[\"level\"]\n        xp = player[\"xp\"]\n\n        while current_level < 9:  # Max level is 9\n            xp_needed = self._get_xp_for_level(current_level)\n            if xp >= xp_needed:\n                xp -= xp_needed\n                current_level += 1\n            else:\n                break\n\n        if current_level > player[\"level\"]:\n            player[\"level\"] = current_level\n            player[\"xp\"] = xp\n            self._save_player(user_id, player)\n            # Record achievement progress\n            achievement_hooks.record_fishing_level(self.bot, username, current_level)\n            return current_level\n\n        player[\"xp\"] = xp\n        return None\n\n    def _get_cast_distance(self, level: int, location: Dict[str, Any]) -> float:\n        \"\"\"Generate a random cast distance based on level and location.\"\"\"\n        max_dist = location[\"max_distance\"]\n        # Base distance is 30-70% of max, with level adding potential\n        min_dist = max_dist * 0.3\n        level_bonus = (level / 9) * 0.3  # Up to 30% bonus at max level\n        base_max = max_dist * (0.7 + level_bonus)\n        return round(random.uniform(min_dist, base_max), 1)\n\n    def _select_rarity(self, wait_hours: float, event: Optional[Dict[str, Any]] = None, water_boost: float = 0.0) -> str:\n        \"\"\"Select a rarity tier based on wait time, active events, and hydration boost.\"\"\"\n        weights = RARITY_WEIGHTS.copy()\n\n        # Adjust weights based on wait time\n        # < 6 hours: only common really\n        # 6-12: uncommon possible\n        # 12-18: rare possible\n        # 18-24: legendary possible\n\n        if wait_hours < 6:\n            weights[\"uncommon\"] = 5\n            weights[\"rare\"] = 0\n            weights[\"legendary\"] = 0\n        elif wait_hours < 12:\n            weights[\"rare\"] = 2\n            weights[\"legendary\"] = 0\n        elif wait_hours < 18:\n            weights[\"legendary\"] = 0\n        # else: full weights at 18+ hours\n\n        # Apply event bonuses\n        if event and event.get(\"effect\") == \"rare_boost\":\n            weights[\"rare\"] = int(weights[\"rare\"] * event.get(\"multiplier\", 1))\n            weights[\"legendary\"] = int(weights[\"legendary\"] * event.get(\"multiplier\", 1))\n\n        # Apply water boost (increases rare and legendary chances)\n        if water_boost > 0:\n            # Reduce common weight by the boost percentage\n            common_reduction = weights[\"common\"] * water_boost\n            weights[\"common\"] = max(1, int(weights[\"common\"] - common_reduction))\n            \n            # Distribute the reduction to rare and legendary\n            weights[\"rare\"] = int(weights[\"rare\"] + common_reduction * 0.6)\n            weights[\"legendary\"] = int(weights[\"legendary\"] + common_reduction * 0.4)\n\n        # Weighted random selection\n        total = sum(weights.values())\n        roll = random.randint(1, total)\n        cumulative = 0\n        for rarity, weight in weights.items():\n            cumulative += weight\n            if roll <= cumulative:\n                return rarity\n        return \"common\"\n\n    def _select_fish(\n        self,\n        location: str,\n        rarity: str,\n        eligible_locations: Optional[List[str]] = None,\n        allow_fallback: bool = True,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Select a fish from the eligible location pools matching the rarity.\"\"\"\n        if eligible_locations:\n            fish_pool = []\n            for loc_name in eligible_locations:\n                fish_pool.extend(FISH_DATABASE.get(loc_name, []))\n        else:\n            fish_pool = FISH_DATABASE.get(location, [])\n        matching = [f for f in fish_pool if f[\"rarity\"] == rarity]\n        if not matching and allow_fallback:\n            # Fall back to common if no fish of that rarity\n            matching = [f for f in fish_pool if f[\"rarity\"] == \"common\"]\n        if not matching:\n            return None\n        return random.choice(matching)\n\n    def _calculate_weight(self, fish: Dict[str, Any], wait_hours: float) -> float:\n        \"\"\"Calculate actual fish weight based on wait time.\"\"\"\n        min_w = fish[\"min_weight\"]\n        max_w = fish[\"max_weight\"]\n\n        # Weight scales with wait time up to 24 hours\n        time_factor = min(wait_hours / self.OPTIMAL_WAIT_HOURS, 1.0)\n\n        # Random variance within the range, biased by time factor\n        base_weight = min_w + (max_w - min_w) * time_factor\n        variance = (max_w - min_w) * 0.2  # 20% variance\n        weight = base_weight + random.uniform(-variance, variance)\n\n        return round(max(min_w, min(max_w, weight)), 2)\n\n    def _get_junk(self, location_type: str) -> str:\n        \"\"\"Get a random junk item.\"\"\"\n        items = JUNK_ITEMS.get(location_type, JUNK_ITEMS[\"terrestrial\"])\n        return random.choice(items)\n\n    def _check_event_trigger(self, channel: str, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"5% chance to trigger a random event on cast.\"\"\"\n        if random.random() > 0.05:\n            return None\n\n        # Select a random event\n        available_events = []\n        for event_id, event in EVENTS.items():\n            # Check if event is location-restricted\n            if \"locations\" in event and location not in event[\"locations\"]:\n                continue\n            available_events.append((event_id, event))\n\n        if not available_events:\n            return None\n\n        event_id, event = random.choice(available_events)\n        expires = datetime.now(UTC) + timedelta(minutes=event[\"duration_minutes\"])\n\n        active_event = {\n            \"type\": event_id,\n            \"name\": event[\"name\"],\n            \"description\": event[\"description\"],\n            \"effect\": event.get(\"effect\"),\n            \"multiplier\": event.get(\"multiplier\", 1.0),\n            \"expires\": expires.isoformat(),\n            \"announced_channels\": [channel],\n        }\n\n        self.set_state(\"active_event\", active_event)\n        self.save_state()\n\n        return active_event\n\n    def _get_active_event(self, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get the currently active event if any and valid for location.\"\"\"\n        event = self.get_state(\"active_event\")\n        if not event:\n            return None\n\n        # Check if expired\n        expires = datetime.fromisoformat(event[\"expires\"])\n        if datetime.now(UTC) >= expires:\n            self.set_state(\"active_event\", None)\n            self.save_state()\n            return None\n\n        # Check location restriction\n        event_data = EVENTS.get(event[\"type\"], {})\n        if \"locations\" in event_data and location not in event_data[\"locations\"]:\n            return None\n\n        return event\n\n    def _get_water_boost(self, player: Dict[str, Any]) -> float:\n        \"\"\"Get the current water boost percentage (0.0 to 0.4 for 0% to 40%).\"\"\"\n        # Check if we need to reset daily counter\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        \n        if water_date != today:\n            # New day, reset counter\n            return 0.0\n        \n        # Each water bottle adds 10% boost, max 4 bottles = 40%\n        water_count = player.get(\"water_today\", 0)\n        return min(water_count * 0.10, 0.40)\n\n    def _cmd_cast(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if already has active cast\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you already have a line in the water at {cast['location']}! \"\n                f\"It's been {hours:.1f} hours. Use !reel to bring it in.\"\n            )\n            return True\n\n        player = self._get_player(user_id)\n        \n        # Check if location argument was provided\n        location_arg = match.group(1)\n        if location_arg:\n            # Try to find the requested location\n            requested_location = self._find_location_by_name(location_arg)\n            \n            if not requested_location:\n                # List all available locations\n                available_locs = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, location '{location_arg}' not found. \"\n                    f\"Available locations: {', '.join(available_locs)}\"\n                )\n                return True\n            \n            # Check if player has unlocked this location\n            if requested_location[\"level\"] > player[\"level\"]:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't unlocked {requested_location['name']} yet! \"\n                    f\"You need to be level {requested_location['level']} (currently level {player['level']}).\"\n                )\n                return True\n            \n            location = requested_location\n        else:\n            # No location specified, use current level's default location\n            location = self._get_location_for_level(player[\"level\"])\n        \n        distance = self._get_cast_distance(player[\"level\"], location)\n\n        # Record the cast\n        active_casts[user_id] = {\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"distance\": distance,\n            \"location\": location[\"name\"],\n            \"channel\": event.target,\n            \"allow_lower_fish\": not location_arg,\n        }\n        self.set_state(\"active_casts\", active_casts)\n\n        # Update player stats\n        player[\"total_casts\"] += 1\n        if distance > player[\"furthest_cast\"]:\n            player[\"furthest_cast\"] = distance\n        self._save_player(user_id, player)\n\n        # Check for event trigger\n        triggered_event = self._check_event_trigger(event.target, location[\"name\"])\n\n        # Send cast message\n        cast_msg = random.choice(CAST_MESSAGES).format(\n            distance=distance,\n            location=location[\"name\"]\n        )\n        self.safe_reply(connection, event, f\"{self.bot.title_for(username)}, {cast_msg}\")\n\n        # Announce event if triggered\n        if triggered_event:\n            self.safe_say(\n                f\"** {triggered_event['name']} ** - {triggered_event['description']}\",\n                target=event.target\n            )\n\n        return True\n\n    def _cmd_reel(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if has active cast\n        if user_id not in active_casts:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you don't have a line in the water. Use !cast first.\"\n            )\n            return True\n\n        cast = active_casts[user_id]\n        cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n        now = datetime.now(UTC)\n        elapsed = now - cast_time\n        wait_hours = elapsed.total_seconds() / 3600\n\n        location_name = cast[\"location\"]\n        location = next((l for l in LOCATIONS if l[\"name\"] == location_name), LOCATIONS[0])\n        player = self._get_player(user_id)\n        forced_rare_flag = player.get(\"force_rare_legendary\", False)\n\n        # Remove the cast\n        del active_casts[user_id]\n        self.set_state(\"active_casts\", active_casts)\n        self.save_state()\n\n        # Get active event\n        active_event = self._get_active_event(location_name)\n\n        # Apply time boost event if active\n        effective_wait = wait_hours\n        if active_event and active_event.get(\"effect\") == \"time_boost\":\n            effective_wait = wait_hours / active_event.get(\"multiplier\", 1.0)\n\n        # Too early - nothing caught\n        if effective_wait < self.MIN_WAIT_HOURS:\n            self.safe_reply(connection, event, random.choice(TOO_EARLY_MESSAGES))\n            return True\n\n        # Danger zone - chance of bad outcome\n        if wait_hours > self.DANGER_THRESHOLD_HOURS and not forced_rare_flag:\n            hours_over = wait_hours - self.DANGER_THRESHOLD_HOURS\n            bad_chance = min(0.1 + (hours_over * 0.05), 0.9)\n\n            if random.random() < bad_chance:\n                # Bad outcome\n                bad_type = random.choice([\"line_break\", \"fish_escaped\", \"junk\"])\n\n                if bad_type == \"line_break\":\n                    player[\"lines_broken\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"line_break\"])\n                    )\n                elif bad_type == \"fish_escaped\":\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"fish_escaped\"])\n                    )\n                else:  # junk\n                    junk = self._get_junk(location[\"type\"])\n                    player[\"junk_collected\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        f\"After waiting {wait_hours:.1f} hours, you reel in... {junk}. \"\n                        \"Maybe don't leave your line out so long next time.\"\n                    )\n                return True\n\n        # Junk check (base chance, boosted by murky waters)\n        if not forced_rare_flag:\n            junk_chance = 0.10\n            if active_event and active_event.get(\"effect\") == \"junk_boost\":\n                junk_chance *= active_event.get(\"multiplier\", 1.0)\n\n            if random.random() < junk_chance:\n                junk = self._get_junk(location[\"type\"])\n                player[\"junk_collected\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                xp_gain = 5  # Small XP for junk\n                player[\"xp\"] += xp_gain\n                self._save_player(user_id, player)\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)} reels in... {junk}. \"\n                    f\"Well, at least you're cleaning up! (+{xp_gain} XP)\"\n                )\n                return True\n\n        # Successful catch!\n        water_boost = self._get_water_boost(player)\n        rarity = self._select_rarity(effective_wait, active_event, water_boost)\n        eligible_locations = None\n        if cast.get(\"allow_lower_fish\"):\n            eligible_locations = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        fish = None\n        forced_rare = player.get(\"force_rare_legendary\", False)\n        forced_rare_applied = False\n        if forced_rare:\n            forced_rarities = [\"rare\", \"legendary\"]\n            random.shuffle(forced_rarities)\n            for forced in forced_rarities:\n                fish = self._select_fish(\n                    location_name,\n                    forced,\n                    eligible_locations,\n                    allow_fallback=False,\n                )\n                if fish:\n                    rarity = forced\n                    forced_rare_applied = True\n                    break\n\n        if not fish:\n            fish = self._select_fish(location_name, rarity, eligible_locations)\n\n        if not fish:\n            # Fallback - shouldn't happen\n            self.safe_reply(connection, event, \"The fish got away at the last moment!\")\n            return True\n\n        weight = self._calculate_weight(fish, effective_wait)\n\n        # Line break check - bigger fish = higher chance\n        if not forced_rare_applied:\n            break_chance = 0.02 + (weight / 1000) * 0.15\n            if random.random() < break_chance:\n                player[\"lines_broken\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                self.safe_reply(\n                    connection, event,\n                    f\"You feel a massive tug - it's a {fish['name']}! But the weight is too much... \"\n                    f\"SNAP! The line breaks! It got away...\"\n                )\n                return True\n\n        # Successful catch!\n        player[\"total_fish\"] += 1\n        if weight > player[\"biggest_fish\"]:\n            player[\"biggest_fish\"] = weight\n            player[\"biggest_fish_name\"] = fish[\"name\"]\n\n        if forced_rare_applied:\n            player[\"force_rare_legendary\"] = False\n\n        # Track catches (global)\n        catches = player.get(\"catches\", {})\n        catches[fish[\"name\"]] = catches.get(fish[\"name\"], 0) + 1\n        player[\"catches\"] = catches\n\n        # Track catches by location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        if location_name not in catches_by_location:\n            catches_by_location[location_name] = {}\n        catches_by_location[location_name][fish[\"name\"]] = catches_by_location[location_name].get(fish[\"name\"], 0) + 1\n        player[\"catches_by_location\"] = catches_by_location\n\n        # Track location\n        if location_name not in player.get(\"locations_fished\", []):\n            player.setdefault(\"locations_fished\", []).append(location_name)\n\n        # Track rare/legendary for aquarium\n        if rarity in (\"rare\", \"legendary\"):\n            rare_catches = player.get(\"rare_catches\", [])\n            rare_catches.append({\n                \"name\": fish[\"name\"],\n                \"weight\": weight,\n                \"rarity\": rarity,\n                \"location\": location_name,\n                \"caught_at\": now.isoformat(),\n            })\n            player[\"rare_catches\"] = rare_catches\n\n        # Calculate XP\n        base_xp = 10\n        rarity_mult = RARITY_XP_MULTIPLIER.get(rarity, 1)\n        weight_bonus = 1 + (weight / 50)\n        xp_gain = int(base_xp * rarity_mult * weight_bonus)\n\n        # Event XP boost\n        if active_event and active_event.get(\"effect\") == \"xp_boost\":\n            xp_gain = int(xp_gain * active_event.get(\"multiplier\", 1.0))\n\n        bonus_messages = []\n        boost_catches = player.get(\"xp_boost_catches\", 0)\n        if boost_catches > 0:\n            xp_gain = int(xp_gain * XP_BOOST_MULTIPLIER)\n            boost_catches -= 1\n            player[\"xp_boost_catches\"] = boost_catches\n            bonus_messages.append(f\"Rod boost! x{XP_BOOST_MULTIPLIER} XP.\")\n            if boost_catches == 0:\n                bonus_messages.append(\"The rod's glow fades.\")\n\n        extra_xp = 0\n        roll = random.random()\n        if roll < XP_BONUS_LARGE_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_LARGE_RANGE)\n            bonus_messages.append(f\"Treasure haul! +{extra_xp} XP.\")\n        elif roll < XP_BONUS_LARGE_CHANCE + XP_BONUS_SMALL_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_SMALL_RANGE)\n            bonus_messages.append(f\"Lucky find! +{extra_xp} XP.\")\n\n        if player.get(\"xp_boost_catches\", 0) == 0 and random.random() < XP_BOOST_ROD_CHANCE:\n            player[\"xp_boost_catches\"] = XP_BOOST_ROD_CATCHES\n            bonus_messages.append(\n                f\"You found a better rod! Next {XP_BOOST_ROD_CATCHES} catches give double XP.\"\n            )\n\n        total_xp = xp_gain + extra_xp\n        player[\"xp\"] += total_xp\n        self._save_player(user_id, player)\n\n        # Record achievements\n        achievement_hooks.record_achievement(self.bot, username, \"fish_caught\", 1)\n        if rarity == \"rare\":\n            achievement_hooks.record_achievement(self.bot, username, \"rare_fish_caught\", 1)\n        elif rarity == \"legendary\":\n            achievement_hooks.record_achievement(self.bot, username, \"legendary_fish_caught\", 1)\n\n        # Perfect wait achievement (18-24 hours)\n        if 18.0 <= wait_hours <= 24.0:\n            achievement_hooks.record_achievement(self.bot, username, \"perfect_waits\", 1)\n\n        # Check level up\n        new_level = self._check_level_up(user_id, player, username)\n\n        # Build response\n        rarity_prefix = \"\"\n        if rarity == \"uncommon\":\n            rarity_prefix = \"an uncommon \"\n        elif rarity == \"rare\":\n            rarity_prefix = \"a RARE \"\n        elif rarity == \"legendary\":\n            rarity_prefix = \"a LEGENDARY \"\n        else:\n            rarity_prefix = \"a \"\n\n        response = (\n            f\"{self.bot.title_for(username)} reels in {rarity_prefix}{fish['name']} \"\n            f\"weighing {weight:.2f} lbs after waiting {wait_hours:.1f} hours! (+{total_xp} XP)\"\n        )\n        if bonus_messages:\n            response += \" \" + \" \".join(bonus_messages)\n        if forced_rare_applied:\n            response += \" A rare blessing guides your catch.\"\n\n        if new_level:\n            new_location = self._get_location_for_level(new_level)\n            response += f\" LEVEL UP! You're now level {new_level} and can fish at {new_location['name']}!\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_fishing_bless(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        target = match.group(1).strip()\n        target_id = self.bot.get_user_id(target)\n        player = self._get_player(target_id)\n        player[\"force_rare_legendary\"] = True\n        self._save_player(target_id, player)\n\n        self.safe_reply(\n            connection,\n            event,\n            f\"{self.bot.title_for(target)}, your next catch will be rare or legendary.\"\n        )\n        return True\n\n    def _cmd_fishing_stats(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        location = self._get_location_for_level(player[\"level\"])\n\n        xp_needed = self._get_xp_for_level(player[\"level\"])\n        xp_progress = f\"{player['xp']}/{xp_needed}\"\n\n        stats = (\n            f\"Fishing Stats for {self.bot.title_for(username)}: \"\n            f\"Level {player['level']} ({location['name']}) | \"\n            f\"XP: {xp_progress} | \"\n            f\"Fish: {player['total_fish']} | \"\n            f\"Biggest: {player['biggest_fish']:.2f} lbs\"\n        )\n\n        if player.get(\"biggest_fish_name\"):\n            stats += f\" ({player['biggest_fish_name']})\"\n\n        stats += f\" | Casts: {player['total_casts']} | Junk: {player['junk_collected']}\"\n\n        self.safe_reply(connection, event, stats)\n        return True\n\n    def _cmd_fishing_top(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        players = self.get_state(\"players\", {})\n        if not players:\n            self.safe_reply(connection, event, \"No one has gone fishing yet!\")\n            return True\n\n        # Get user map for display names\n        user_map = self.bot.get_module_state(\"users\").get(\"user_map\", {})\n\n        # Top by total fish\n        by_fish = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"total_fish\", 0) > 0],\n            key=lambda x: x[1][\"total_fish\"],\n            reverse=True\n        )[:5]\n\n        # Top by biggest fish\n        by_size = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"biggest_fish\", 0) > 0],\n            key=lambda x: x[1][\"biggest_fish\"],\n            reverse=True\n        )[:5]\n\n        response_parts = [\"Fishing Leaderboards:\"]\n\n        if by_fish:\n            fish_list = []\n            for i, (uid, p) in enumerate(by_fish):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_list.append(f\"#{i+1} {name} ({p['total_fish']})\")\n            response_parts.append(\"Most Fish: \" + \", \".join(fish_list))\n\n        if by_size:\n            size_list = []\n            for i, (uid, p) in enumerate(by_size):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_name = p.get(\"biggest_fish_name\", \"fish\")\n                size_list.append(f\"#{i+1} {name} ({p['biggest_fish']:.1f} lbs - {fish_name})\")\n            response_parts.append(\"Biggest Catch: \" + \", \".join(size_list))\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishing_location(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        current_loc = self._get_location_for_level(player[\"level\"])\n\n        # Check for active cast\n        active_casts = self.get_state(\"active_casts\", {})\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}: Currently fishing at {cast['location']} \"\n                f\"(line out for {hours:.1f} hours). Level {player['level']}.\"\n            )\n            return True\n\n        # Build location progress\n        unlocked = [l for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        next_loc = next((l for l in LOCATIONS if l[\"level\"] > player[\"level\"]), None)\n\n        response = (\n            f\"{self.bot.title_for(username)}: Level {player['level']}, \"\n            f\"currently at {current_loc['name']}. \"\n            f\"Unlocked: {', '.join(l['name'] for l in unlocked)}.\"\n        )\n\n        if next_loc:\n            xp_needed = self._get_xp_for_level(player[\"level\"])\n            response += f\" Next: {next_loc['name']} at level {next_loc['level']} ({player['xp']}/{xp_needed} XP).\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_aquarium(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        rare_catches = player.get(\"rare_catches\", [])\n\n        if not rare_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}'s aquarium is empty. \"\n                \"Catch some rare or legendary fish to display them here!\"\n            )\n            return True\n\n        # Group by rarity\n        legendaries = [c for c in rare_catches if c[\"rarity\"] == \"legendary\"]\n        rares = [c for c in rare_catches if c[\"rarity\"] == \"rare\"]\n\n        response_parts = [f\"{self.bot.title_for(username)}'s Aquarium:\"]\n\n        if legendaries:\n            leg_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in legendaries[-5:]  # Last 5\n            )\n            response_parts.append(f\"LEGENDARY: {leg_display}\")\n\n        if rares:\n            rare_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in rares[-5:]  # Last 5\n            )\n            response_parts.append(f\"Rare: {rare_display}\")\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishinfo(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        \n        # Get location argument\n        location_arg = match.group(1)\n        \n        if not location_arg:\n            # No location specified - show available locations\n            locations_fished = player.get(\"locations_fished\", [])\n            if not locations_fished:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't caught any fish yet! \"\n                    \"Use !cast and !reel to start fishing.\"\n                )\n                return True\n            \n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, locations you've fished: {', '.join(locations_fished)}. \"\n                \"Use !fishinfo <location> to see fish caught there.\"\n            )\n            return True\n        \n        # Find the location\n        location = self._find_location_by_name(location_arg)\n        if not location:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, location '{location_arg}' not found.\"\n            )\n            return True\n        \n        location_name = location[\"name\"]\n        \n        # Get catches for this location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        location_catches = catches_by_location.get(location_name, {})\n        \n        if not location_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you haven't caught any fish at {location_name} yet!\"\n            )\n            return True\n        \n        # Get all fish available at this location for completion stats\n        all_fish = FISH_DATABASE.get(location_name, [])\n        total_species = len(all_fish)\n        caught_species = len(location_catches)\n        \n        # Group by rarity\n        caught_by_rarity = {\"common\": [], \"uncommon\": [], \"rare\": [], \"legendary\": []}\n        for fish_name, count in location_catches.items():\n            # Find the fish in the database to get its rarity\n            fish_data = next((f for f in all_fish if f[\"name\"] == fish_name), None)\n            if fish_data:\n                rarity = fish_data[\"rarity\"]\n                caught_by_rarity[rarity].append(f\"{fish_name} ({count})\")\n        \n        # Build response\n        total_caught = sum(location_catches.values())\n        response_parts = [\n            f\"{self.bot.title_for(username)}'s {location_name} catches: \"\n            f\"{total_caught} fish, {caught_species}/{total_species} species\"\n        ]\n        \n        # Add fish by rarity\n        for rarity in [\"legendary\", \"rare\", \"uncommon\", \"common\"]:\n            if caught_by_rarity[rarity]:\n                rarity_label = rarity.upper() if rarity in [\"legendary\", \"rare\"] else rarity.capitalize()\n                fish_list = \", \".join(caught_by_rarity[rarity])\n                response_parts.append(f\"{rarity_label}: {fish_list}\")\n        \n        # Send as multiple messages if too long\n        full_response = \" | \".join(response_parts)\n        if len(full_response) > 400:\n            # Send in parts\n            self.safe_reply(connection, event, response_parts[0])\n            for part in response_parts[1:]:\n                self.safe_say(part, target=event.target)\n        else:\n            self.safe_reply(connection, event, full_response)\n        \n        return True\n\n    def _cmd_fishing_help(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        help_lines = [\n            \"Fishing Commands:\",\n            \"!cast - Cast at your current level (can catch fish from any unlocked lower levels)\",\n            \"!cast <location> - Cast at a specific unlocked location (e.g., !cast pond)\",\n            \"!reel - Reel in your catch (wait 1-24 hours for best results)\",\n            \"!fishing - Show your stats\",\n            \"!fishing top - Leaderboards\",\n            \"!fishing location - Current location and level progress\",\n            \"!fishinfo - List locations you've fished\",\n            \"!fishinfo <location> - Show fish caught at a specific location (e.g., !fishinfo pond)\",\n            \"!aquarium - View your rare/legendary catches\",\n            \"!water - Celebrate finishing a water bottle (boosts rare fish, max 4/day)\",\n            \"\",\n            \"Tips: !cast pulls fish from your current level and any lower unlocked levels.\",\n            \"You can also travel back to previous locations to hunt for rare fish you missed!\",\n            \"Stay hydrated! Each bottle of water increases rare fish chances by 10% (up to 40%).\",\n        ]\n\n        for line in help_lines:\n            self.safe_privmsg(username, line)\n\n        self.safe_reply(\n            connection, event,\n            f\"{self.bot.title_for(username)}, I've sent you the fishing guide.\"\n        )\n        return True\n\n    def _cmd_water(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n\n        # Get today's date\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        water_count = player.get(\"water_today\", 0)\n\n        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check if they've already had 4 bottles today\n        if water_count >= 4:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you have already consumed your four bottles of water today! \"\n                \"Most commendable dedication to hydration. Do return tomorrow for further encouragement.\"\n            )\n            return True\n\n        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)\n\n        # Calculate new boost percentage\n        boost_percentage = water_count * 10\n\n        # Build response based on how many they've had\n        if water_count == 1:\n            response = (\n                f\"Splendid! {self.bot.title_for(username)}, I am delighted to see you tending to your hydration. \"\n                f\"Three more bottles to go! Your commitment to wellness grants you a {boost_percentage}% boost \"\n                \"to catching rare and legendary fish today.\"\n            )\n        elif water_count == 2:\n            response = (\n                f\"Excellent progress, {self.bot.title_for(username)}! Two bottles down, two more to go! \"\n                f\"Your dedication is most admirable. You now have a {boost_percentage}% boost to rare catches.\"\n            )\n        elif water_count == 3:\n            response = (\n                f\"Marvelous! {self.bot.title_for(username)}, just one more bottle remains! \"\n                f\"You are nearly at peak hydration. Current boost: {boost_percentage}% to rare and legendary fish.\"\n            )\n        else:  # water_count == 4\n            response = (\n                f\"Outstanding! {self.bot.title_for(username)}, you have completed your daily hydration goal! \"\n                f\"I am exceedingly proud of your commitment to health. You now enjoy a magnificent {boost_percentage}% \"\n                \"boost to catching rare and legendary fish for the remainder of the day!\"\n            )\n\n        self.safe_reply(connection, event, response)\n        return True\n","numLines":1358,"startLine":1,"totalLines":1358}},"sourceToolAssistantUUID":"b9da99e7-8582-4c42-a251-67b07dba23cf"}
{"parentUuid":"96118f94-e28b-41d0-9933-94417a6d1e58","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01HgufSUKuDkjVn7LWQ7qGaP","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I understand the code. I need to add a cooldown of at least 1 hour between `!water` commands. I need to:\n\n1. Track the timestamp of the last `!water` usage\n2. Check if at least 1 hour has passed since the last use\n3. If not, give a snarky Jeeves-style response suggesting they're cheating\n\nLet me add a `water_last_used` field to track the last timestamp, and add the check in `_cmd_water`.","signature":"Eq0ECkYICxgCKkC0R90Kg+EnClHd36oF2cUIidT8kRilrVFtnMK7dejo83e2wwGjGEaqYwJub9zkRuddzs+232KTR7MvSE9ZdvG5Egx+6sAeivK5kE3d1TYaDCI7Y6m2hj5sYkJD4CIwdSYIEoaoOGg0qyA6cVZuvVhH74vtjSh8YOw7Z3mMB8DJBjwkCyLbwf9CKzcrjccVKpQD45Oyqr58WEZr1sDeYuVsGC4ul9lDXtCkhxo7fD0bZPqoWqOAgbNpx3vv4gUSXbdBevHYGyyJJ7LqgvGf4S4ol1yugTkkdJsvwb1TXabc13+yNppfeOaF1kbCP6G/INr3q2bA4QKxrr8rvYKmmKWESgt7K0/y6UrpYhRbkU+GpG7sQ8nTSJW20oEsB/5AvNPaEoRxvKXFalySP6HL/tTQdzSt0Jj5TnVezMExGX2aDTCScdkat/TBmjhJ+c0F72GGgOIAdKa89ubjE+CbQPEBUwhYEEEwlG0so8L4xasf3bLJOC4+Uk441q1At70XcGMj8gEc2YHrqAiNOH+lH9xGBkkLSelmNG09VMlJvB+71p944+tNX1X2yas1xoGEhLLl+oMqOXyhFB6cf8yv3NZa7kjJ1OlGskjdkB66kHIDcgTwvMlC+zuSsRQ8IH7OM86nfU2peul5207w0A4SK5q5W6p9kAAqz1pVXipB88fCmJemsmcqsxqvg0VqWuz5Wm1JtJ28f4a1EUSqsUs4eLR0vd+TKRsYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":22306,"cache_read_input_tokens":20291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":22306},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HdqiP65JbALvkgyaLT","type":"assistant","uuid":"652d3673-4475-40a6-8ed4-3ee9b9dbf3cb","timestamp":"2026-02-12T01:13:37.391Z"}
{"parentUuid":"652d3673-4475-40a6-8ed4-3ee9b9dbf3cb","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01HgufSUKuDkjVn7LWQ7qGaP","type":"message","role":"assistant","content":[{"type":"text","text":"I can see the issue - there's no cooldown between `!water` uses, so people just spam it four times. I need to add a `water_last_used` timestamp and enforce a 1-hour cooldown with some appropriately Wodehousian snark."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":22306,"cache_read_input_tokens":20291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":22306},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HdqiP65JbALvkgyaLT","type":"assistant","uuid":"8c80e482-445a-484d-a399-ab0dff689196","timestamp":"2026-02-12T01:13:38.644Z"}
{"parentUuid":"8c80e482-445a-484d-a399-ab0dff689196","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01HgufSUKuDkjVn7LWQ7qGaP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B584bX94rcwDfsRQJZ4Gsv","name":"Edit","input":{"replace_all":false,"file_path":"/home/nylan/code/jeeves/modules/fishing.py","old_string":"                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n","new_string":"                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"water_last_used\": None,  # ISO timestamp of last !water command\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":22306,"cache_read_input_tokens":20291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":22306},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HdqiP65JbALvkgyaLT","type":"assistant","uuid":"29412b1e-8d8b-4be6-8c08-7f0c3f2626e8","timestamp":"2026-02-12T01:13:40.911Z"}
{"type":"file-history-snapshot","messageId":"29412b1e-8d8b-4be6-8c08-7f0c3f2626e8","snapshot":{"messageId":"f281ea56-6784-4145-baa8-1ade32f9562f","trackedFileBackups":{"modules/fishing.py":{"backupFileName":"2bda2111496b2915@v1","version":1,"backupTime":"2026-02-12T01:14:31.531Z"}},"timestamp":"2026-02-12T01:13:28.908Z"},"isSnapshotUpdate":true}
{"parentUuid":"29412b1e-8d8b-4be6-8c08-7f0c3f2626e8","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01B584bX94rcwDfsRQJZ4Gsv","toolUseID":"toolu_01B584bX94rcwDfsRQJZ4Gsv","timestamp":"2026-02-12T01:14:31.536Z","uuid":"fde37f4c-a1a2-450d-bd2a-32d168993773"}
{"parentUuid":"29412b1e-8d8b-4be6-8c08-7f0c3f2626e8","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B584bX94rcwDfsRQJZ4Gsv","type":"tool_result","content":"The file /home/nylan/code/jeeves/modules/fishing.py has been updated successfully."}]},"uuid":"bf84f49b-1df9-45a1-b8e9-e42c76a676b0","timestamp":"2026-02-12T01:14:31.536Z","toolUseResult":{"filePath":"/home/nylan/code/jeeves/modules/fishing.py","oldString":"                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n","newString":"                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"water_last_used\": None,  # ISO timestamp of last !water command\n","originalFile":"# modules/fishing.py\n# A fishing mini-game where users cast lines and reel in catches over time.\n\nimport random\nimport re\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom .base import SimpleCommandModule\nfrom . import achievement_hooks\n\nUTC = timezone.utc\n\n\ndef setup(bot: Any) -> 'Fishing':\n    return Fishing(bot)\n\n\n# Fishing locations unlocked by level (0-9)\nLOCATIONS = [\n    {\"name\": \"Puddle\", \"level\": 0, \"max_distance\": 5, \"type\": \"terrestrial\"},\n    {\"name\": \"Pond\", \"level\": 1, \"max_distance\": 15, \"type\": \"terrestrial\"},\n    {\"name\": \"Lake\", \"level\": 2, \"max_distance\": 30, \"type\": \"terrestrial\"},\n    {\"name\": \"River\", \"level\": 3, \"max_distance\": 50, \"type\": \"terrestrial\"},\n    {\"name\": \"Ocean\", \"level\": 4, \"max_distance\": 100, \"type\": \"terrestrial\"},\n    {\"name\": \"Deep Sea\", \"level\": 5, \"max_distance\": 200, \"type\": \"terrestrial\"},\n    {\"name\": \"Moon\", \"level\": 6, \"max_distance\": 500, \"type\": \"space\"},\n    {\"name\": \"Mars\", \"level\": 7, \"max_distance\": 1000, \"type\": \"space\"},\n    {\"name\": \"Jupiter\", \"level\": 8, \"max_distance\": 2000, \"type\": \"space\"},\n    {\"name\": \"The Void\", \"level\": 9, \"max_distance\": 5000, \"type\": \"space\"},\n]\n\n# Fish database organized by location\n# Each fish has: name, min_weight, max_weight, rarity\nFISH_DATABASE: Dict[str, List[Dict[str, Any]]] = {\n    \"Puddle\": [\n        # Common\n        {\"name\": \"Minnow\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        {\"name\": \"Tadpole\", \"min_weight\": 0.05, \"max_weight\": 0.2, \"rarity\": \"common\"},\n        {\"name\": \"Guppy\", \"min_weight\": 0.1, \"max_weight\": 0.3, \"rarity\": \"common\"},\n        {\"name\": \"Water Beetle\", \"min_weight\": 0.01, \"max_weight\": 0.1, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Goldfish\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Small Frog\", \"min_weight\": 0.3, \"max_weight\": 1.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Koi\", \"min_weight\": 2.0, \"max_weight\": 5.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Puddle King\", \"min_weight\": 8.0, \"max_weight\": 15.0, \"rarity\": \"legendary\"},\n    ],\n    \"Pond\": [\n        # Common\n        {\"name\": \"Bluegill\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Perch\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Sunfish\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Crayfish\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Largemouth Bass\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Catfish\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Perch\", \"min_weight\": 5.0, \"max_weight\": 12.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Old Whiskers\", \"min_weight\": 20.0, \"max_weight\": 40.0, \"rarity\": \"legendary\"},\n    ],\n    \"Lake\": [\n        # Common\n        {\"name\": \"Trout\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Crappie\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Walleye\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Pike\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Lake Sturgeon\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Muskie\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Albino Sturgeon\", \"min_weight\": 20.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Nessie's Cousin\", \"min_weight\": 100.0, \"max_weight\": 200.0, \"rarity\": \"legendary\"},\n    ],\n    \"River\": [\n        # Common\n        {\"name\": \"Salmon\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Steelhead\", \"min_weight\": 4.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        {\"name\": \"River Carp\", \"min_weight\": 3.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Smallmouth Bass\", \"min_weight\": 2.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"King Salmon\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Paddlefish\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Salmon\", \"min_weight\": 25.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The River Guardian\", \"min_weight\": 80.0, \"max_weight\": 150.0, \"rarity\": \"legendary\"},\n    ],\n    \"Ocean\": [\n        # Common\n        {\"name\": \"Tuna\", \"min_weight\": 20.0, \"max_weight\": 80.0, \"rarity\": \"common\"},\n        {\"name\": \"Mackerel\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Sea Bass\", \"min_weight\": 10.0, \"max_weight\": 40.0, \"rarity\": \"common\"},\n        {\"name\": \"Flounder\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Swordfish\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Mahi-Mahi\", \"min_weight\": 15.0, \"max_weight\": 50.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Barracuda\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Blue Marlin\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Sailfish\", \"min_weight\": 80.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Moby Dick Jr.\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Deep Sea\": [\n        # Common\n        {\"name\": \"Anglerfish\", \"min_weight\": 5.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Viperfish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Gulper Eel\", \"min_weight\": 3.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Lanternfish\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Giant Squid\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Oarfish\", \"min_weight\": 30.0, \"max_weight\": 100.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Goblin Shark\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Colossal Squid\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Megamouth Shark\", \"min_weight\": 300.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Kraken\", \"min_weight\": 1000.0, \"max_weight\": 2500.0, \"rarity\": \"legendary\"},\n    ],\n    \"Moon\": [\n        # Common\n        {\"name\": \"Moon Jellyfish\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Lunar Shrimp\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Crater Minnow\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Dust Swimmer\", \"min_weight\": 1.0, \"max_weight\": 4.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Crater Crab\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Void Eel\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Selenite Fish\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Cosmic Whale\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        {\"name\": \"Starlight Serpent\", \"min_weight\": 40.0, \"max_weight\": 150.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Leviathan of Tranquility\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Mars\": [\n        # Common\n        {\"name\": \"Rust Minnow\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Red Silt Crawler\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Iron Guppy\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Dust Devil Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Olympus Bass\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Valles Trout\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Phobos Flounder\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Martian Kraken\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Red Planet Leviathan\", \"min_weight\": 150.0, \"max_weight\": 400.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Ancient One\", \"min_weight\": 1000.0, \"max_weight\": 2000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Jupiter\": [\n        # Common\n        {\"name\": \"Gas Giant Jellyfish\", \"min_weight\": 2.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Storm Swimmer\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Ammonia Minnow\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Cloud Drifter\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Red Spot Ray\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Ammonia Eel\", \"min_weight\": 30.0, \"max_weight\": 80.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Io Salmon\", \"min_weight\": 25.0, \"max_weight\": 70.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Jovian Leviathan\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Europa Ice Beast\", \"min_weight\": 250.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Great Red Serpent\", \"min_weight\": 2000.0, \"max_weight\": 4000.0, \"rarity\": \"legendary\"},\n    ],\n    \"The Void\": [\n        # Common\n        {\"name\": \"Void Mite\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Dark Matter Shrimp\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Null Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Entropy Minnow\", \"min_weight\": 1.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Entropy Eel\", \"min_weight\": 25.0, \"max_weight\": 75.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Singularity Squid\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Dimensional Drifter\", \"min_weight\": 40.0, \"max_weight\": 120.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Reality Warper\", \"min_weight\": 300.0, \"max_weight\": 800.0, \"rarity\": \"rare\"},\n        {\"name\": \"Event Horizon Eel\", \"min_weight\": 400.0, \"max_weight\": 900.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Cosmic Horror\", \"min_weight\": 5000.0, \"max_weight\": 10000.0, \"rarity\": \"legendary\"},\n        {\"name\": \"Cthulhu's Cousin\", \"min_weight\": 8000.0, \"max_weight\": 15000.0, \"rarity\": \"legendary\"},\n    ],\n}\n\n# Junk items by location type\nJUNK_ITEMS: Dict[str, List[str]] = {\n    \"terrestrial\": [\n        \"Old Boot\", \"Rusty Tin Can\", \"Soggy Newspaper\", \"Tangled Fishing Line\",\n        \"Broken Sunglasses\", \"Waterlogged Book\", \"Deflated Beach Ball\", \"Lost Flip-Flop\",\n        \"Shopping Cart Wheel\", \"Plastic Bottle\", \"Tire\", \"Underwear\", \"License Plate\",\n        \"Broken Umbrella\", \"Moldy Wallet\", \"Damp Cigarette Pack\", \"Fishing Bobber\",\n        \"Knitting Needle\", \"Crochet Hook\", \"Tangled Yarn Ball\", \"Stitch Marker\",\n        \"Frayed Crochet Bag\", \"Half-Finished Scarf\", \"Pattern Printout\",\n        \"Game Controller\", \"Pixelated Cartridge\", \"Arcade Token\", \"Headset Mic\",\n        \"Trophy Cup\", \"Resistance Band\", \"Kettlebell\", \"Gym Towel\",\n        \"Protein Shaker\", \"Yoga Mat\", \"Jump Rope\",\n    ],\n    \"space\": [\n        \"Space Debris\", \"Frozen Oxygen Chunk\", \"Abandoned Satellite\", \"Lost Astronaut Glove\",\n        \"Alien Artifact\", \"Meteor Fragment\", \"Cosmic Dust Bunny\", \"Derelict Probe\",\n        \"Ancient Star Map\", \"Fossilized Moonrock\", \"Mysterious Orb\", \"Quantum Fluctuation\",\n        \"Void Crystal\", \"Broken Warp Core\", \"Lost Space Buoy\", \"Crystallized Stardust\",\n        \"Zero-G Yarn Ball\", \"Starlight Crochet Hook\", \"Orbital Knitting Needle\",\n        \"Cosmic Game Controller\", \"Nebula Cartridge\", \"Warped Arcade Token\",\n        \"Anti-Gravity Kettlebell\", \"Meteorite Dumbbell\", \"Vacuum-Sealed Gym Towel\",\n        \"Protein Paste Packet\", \"Quantum Jump Rope\",\n    ],\n}\n\n# Random events that can trigger\nEVENTS: Dict[str, Dict[str, Any]] = {\n    \"full_moon\": {\n        \"name\": \"Full Moon\",\n        \"description\": \"The full moon rises! Rare fish are more active.\",\n        \"effect\": \"rare_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 30,\n    },\n    \"solar_flare\": {\n        \"name\": \"Solar Flare\",\n        \"description\": \"A solar flare energizes the waters! Double XP!\",\n        \"effect\": \"xp_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n    \"feeding_frenzy\": {\n        \"name\": \"Feeding Frenzy\",\n        \"description\": \"The fish are hungry! Catches are easier.\",\n        \"effect\": \"time_boost\",\n        \"multiplier\": 0.5,  # Halves effective required time\n        \"duration_minutes\": 25,\n    },\n    \"murky_waters\": {\n        \"name\": \"Murky Waters\",\n        \"description\": \"The waters are murky... more junk than usual.\",\n        \"effect\": \"junk_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 15,\n    },\n    \"meteor_shower\": {\n        \"name\": \"Meteor Shower\",\n        \"description\": \"A meteor shower brings strange creatures from beyond!\",\n        \"effect\": \"alien_fish\",\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n}\n\n# Rarity weights for fish selection\nRARITY_WEIGHTS = {\n    \"common\": 70,\n    \"uncommon\": 20,\n    \"rare\": 8,\n    \"legendary\": 2,\n}\n\n# XP multipliers by rarity\nRARITY_XP_MULTIPLIER = {\n    \"common\": 1,\n    \"uncommon\": 2,\n    \"rare\": 5,\n    \"legendary\": 20,\n}\n\n# XP bonus chances (per successful catch)\nXP_BONUS_SMALL_CHANCE = 0.04\nXP_BONUS_LARGE_CHANCE = 0.01\nXP_BOOST_ROD_CHANCE = 0.007\nXP_BOOST_ROD_CATCHES = 5\nXP_BOOST_MULTIPLIER = 2\nXP_BONUS_SMALL_RANGE = (8, 20)\nXP_BONUS_LARGE_RANGE = (40, 90)\n\n# Cast flavor messages\nCAST_MESSAGES = [\n    \"You cast your line, it goes {distance}m and floats quietly...\",\n    \"With a practiced flick, your line sails {distance}m into the {location}.\",\n    \"Your line arcs gracefully, landing {distance}m away in the {location}.\",\n    \"The line whips through the air, settling {distance}m out.\",\n    \"You send your line sailing {distance}m. Now we wait...\",\n]\n\n# Reel too early messages\nTOO_EARLY_MESSAGES = [\n    \"You reel in too soon - the line is empty. Perhaps patience is a virtue?\",\n    \"Nothing but an empty hook. The fish need more time to find your bait.\",\n    \"Your line comes back bare. Try waiting a bit longer next time.\",\n    \"Too hasty! The fish haven't even noticed your bait yet.\",\n    \"An empty catch. Good things come to those who wait.\",\n]\n\n# Danger zone messages (over 24 hours)\nDANGER_ZONE_MESSAGES = {\n    \"line_break\": [\n        \"The line finally snaps from the strain! It was out there too long.\",\n        \"Your line, weakened by time, breaks as you try to reel in.\",\n        \"The elements have taken their toll - your line breaks clean off!\",\n    ],\n    \"fish_escaped\": [\n        \"The fish got tired of waiting and swam away ages ago.\",\n        \"Whatever was on the line has long since escaped.\",\n        \"You reel in... nothing. The fish left hours ago.\",\n    ],\n    \"junk\": [\n        \"After all that time, you only catch some waterlogged junk.\",\n        \"The long wait rewards you with... garbage. How fitting.\",\n    ],\n}\n\n\nclass Fishing(SimpleCommandModule):\n    name = \"fishing\"\n    version = \"1.0.0\"\n    description = \"A fishing mini-game with locations, leveling, and rare catches.\"\n\n    # Time thresholds in hours\n    MIN_WAIT_HOURS = 1.0\n    OPTIMAL_WAIT_HOURS = 24.0\n    DANGER_THRESHOLD_HOURS = 24.0\n    MAX_DANGER_HOURS = 48.0\n\n    def __init__(self, bot: Any) -> None:\n        super().__init__(bot)\n\n        # Initialize state\n        if not self.get_state(\"active_casts\"):\n            self.set_state(\"active_casts\", {})\n        if not self.get_state(\"players\"):\n            self.set_state(\"players\", {})\n        if not self.get_state(\"active_event\"):\n            self.set_state(\"active_event\", None)\n        self.save_state()\n\n    def _register_commands(self) -> None:\n        self.register_command(\n            r'^\\s*!cast(?:\\s+(.+))?\\s*$',\n            self._cmd_cast,\n            name=\"cast\",\n            description=\"Cast your fishing line (optionally specify location)\"\n        )\n        self.register_command(\n            r'^\\s*!reel\\s*$',\n            self._cmd_reel,\n            name=\"reel\",\n            description=\"Reel in your catch\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing|stats)?\\s*$',\n            self._cmd_fishing_stats,\n            name=\"fishing\",\n            description=\"Show your fishing statistics\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+top\\s*$',\n            self._cmd_fishing_top,\n            name=\"fishing top\",\n            description=\"Show fishing leaderboards\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+location\\s*$',\n            self._cmd_fishing_location,\n            name=\"fishing location\",\n            description=\"Show your current fishing location\"\n        )\n        self.register_command(\n            r'^\\s*!fishinfo(?:\\s+(.+))?\\s*$',\n            self._cmd_fishinfo,\n            name=\"fishinfo\",\n            description=\"Show fish caught in a specific location\"\n        )\n        self.register_command(\n            r'^\\s*!aquarium\\s*$',\n            self._cmd_aquarium,\n            name=\"aquarium\",\n            description=\"Show your rare and legendary catches\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+help\\s*$',\n            self._cmd_fishing_help,\n            name=\"fishing help\",\n            description=\"Show fishing help\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+bless\\s+(\\S+)\\s*$',\n            self._cmd_fishing_bless,\n            name=\"fishing bless\",\n            admin_only=True,\n            description=\"[Admin] Guarantee a user's next catch is rare or legendary\"\n        )\n        self.register_command(\n            r'^\\s*!water\\s*$',\n            self._cmd_water,\n            name=\"water\",\n            description=\"Celebrate finishing a water bottle (boosts rare fish chances)\"\n        )\n\n    def _get_player(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Get or create a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        if user_id not in players:\n            players[user_id] = {\n                \"level\": 0,\n                \"xp\": 0,\n                \"total_fish\": 0,\n                \"biggest_fish\": 0.0,\n                \"biggest_fish_name\": None,\n                \"total_casts\": 0,\n                \"furthest_cast\": 0.0,\n                \"lines_broken\": 0,\n                \"junk_collected\": 0,\n                \"catches\": {},\n                \"catches_by_location\": {},  # {\"location_name\": {\"fish_name\": count}}\n                \"rare_catches\": [],\n                \"locations_fished\": [],\n                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"xp_boost_catches\": 0,\n                \"force_rare_legendary\": False,\n            }\n            self.set_state(\"players\", players)\n            self.save_state()\n        return players[user_id]\n\n    def _save_player(self, user_id: str, player: Dict[str, Any]) -> None:\n        \"\"\"Save a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        players[user_id] = player\n        self.set_state(\"players\", players)\n        self.save_state()\n\n    def _get_location_for_level(self, level: int) -> Dict[str, Any]:\n        \"\"\"Get the location a player can fish at based on their level.\"\"\"\n        # Player fishes at their max unlocked location\n        for loc in reversed(LOCATIONS):\n            if loc[\"level\"] <= level:\n                return loc\n        return LOCATIONS[0]\n\n    def _find_location_by_name(self, location_query: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Find a location by name (case-insensitive, supports partial matches).\"\"\"\n        query = location_query.strip().lower()\n        \n        # Try exact match first\n        for loc in LOCATIONS:\n            if loc[\"name\"].lower() == query:\n                return loc\n        \n        # Try partial match\n        for loc in LOCATIONS:\n            if query in loc[\"name\"].lower():\n                return loc\n        \n        return None\n\n    def _get_xp_for_level(self, level: int) -> int:\n        \"\"\"Calculate XP needed for a level.\"\"\"\n        return int(100 * ((level + 1) ** 1.5))\n\n    def _check_level_up(self, user_id: str, player: Dict[str, Any], username: str) -> Optional[int]:\n        \"\"\"Check if player leveled up, return new level if so.\"\"\"\n        current_level = player[\"level\"]\n        xp = player[\"xp\"]\n\n        while current_level < 9:  # Max level is 9\n            xp_needed = self._get_xp_for_level(current_level)\n            if xp >= xp_needed:\n                xp -= xp_needed\n                current_level += 1\n            else:\n                break\n\n        if current_level > player[\"level\"]:\n            player[\"level\"] = current_level\n            player[\"xp\"] = xp\n            self._save_player(user_id, player)\n            # Record achievement progress\n            achievement_hooks.record_fishing_level(self.bot, username, current_level)\n            return current_level\n\n        player[\"xp\"] = xp\n        return None\n\n    def _get_cast_distance(self, level: int, location: Dict[str, Any]) -> float:\n        \"\"\"Generate a random cast distance based on level and location.\"\"\"\n        max_dist = location[\"max_distance\"]\n        # Base distance is 30-70% of max, with level adding potential\n        min_dist = max_dist * 0.3\n        level_bonus = (level / 9) * 0.3  # Up to 30% bonus at max level\n        base_max = max_dist * (0.7 + level_bonus)\n        return round(random.uniform(min_dist, base_max), 1)\n\n    def _select_rarity(self, wait_hours: float, event: Optional[Dict[str, Any]] = None, water_boost: float = 0.0) -> str:\n        \"\"\"Select a rarity tier based on wait time, active events, and hydration boost.\"\"\"\n        weights = RARITY_WEIGHTS.copy()\n\n        # Adjust weights based on wait time\n        # < 6 hours: only common really\n        # 6-12: uncommon possible\n        # 12-18: rare possible\n        # 18-24: legendary possible\n\n        if wait_hours < 6:\n            weights[\"uncommon\"] = 5\n            weights[\"rare\"] = 0\n            weights[\"legendary\"] = 0\n        elif wait_hours < 12:\n            weights[\"rare\"] = 2\n            weights[\"legendary\"] = 0\n        elif wait_hours < 18:\n            weights[\"legendary\"] = 0\n        # else: full weights at 18+ hours\n\n        # Apply event bonuses\n        if event and event.get(\"effect\") == \"rare_boost\":\n            weights[\"rare\"] = int(weights[\"rare\"] * event.get(\"multiplier\", 1))\n            weights[\"legendary\"] = int(weights[\"legendary\"] * event.get(\"multiplier\", 1))\n\n        # Apply water boost (increases rare and legendary chances)\n        if water_boost > 0:\n            # Reduce common weight by the boost percentage\n            common_reduction = weights[\"common\"] * water_boost\n            weights[\"common\"] = max(1, int(weights[\"common\"] - common_reduction))\n            \n            # Distribute the reduction to rare and legendary\n            weights[\"rare\"] = int(weights[\"rare\"] + common_reduction * 0.6)\n            weights[\"legendary\"] = int(weights[\"legendary\"] + common_reduction * 0.4)\n\n        # Weighted random selection\n        total = sum(weights.values())\n        roll = random.randint(1, total)\n        cumulative = 0\n        for rarity, weight in weights.items():\n            cumulative += weight\n            if roll <= cumulative:\n                return rarity\n        return \"common\"\n\n    def _select_fish(\n        self,\n        location: str,\n        rarity: str,\n        eligible_locations: Optional[List[str]] = None,\n        allow_fallback: bool = True,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Select a fish from the eligible location pools matching the rarity.\"\"\"\n        if eligible_locations:\n            fish_pool = []\n            for loc_name in eligible_locations:\n                fish_pool.extend(FISH_DATABASE.get(loc_name, []))\n        else:\n            fish_pool = FISH_DATABASE.get(location, [])\n        matching = [f for f in fish_pool if f[\"rarity\"] == rarity]\n        if not matching and allow_fallback:\n            # Fall back to common if no fish of that rarity\n            matching = [f for f in fish_pool if f[\"rarity\"] == \"common\"]\n        if not matching:\n            return None\n        return random.choice(matching)\n\n    def _calculate_weight(self, fish: Dict[str, Any], wait_hours: float) -> float:\n        \"\"\"Calculate actual fish weight based on wait time.\"\"\"\n        min_w = fish[\"min_weight\"]\n        max_w = fish[\"max_weight\"]\n\n        # Weight scales with wait time up to 24 hours\n        time_factor = min(wait_hours / self.OPTIMAL_WAIT_HOURS, 1.0)\n\n        # Random variance within the range, biased by time factor\n        base_weight = min_w + (max_w - min_w) * time_factor\n        variance = (max_w - min_w) * 0.2  # 20% variance\n        weight = base_weight + random.uniform(-variance, variance)\n\n        return round(max(min_w, min(max_w, weight)), 2)\n\n    def _get_junk(self, location_type: str) -> str:\n        \"\"\"Get a random junk item.\"\"\"\n        items = JUNK_ITEMS.get(location_type, JUNK_ITEMS[\"terrestrial\"])\n        return random.choice(items)\n\n    def _check_event_trigger(self, channel: str, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"5% chance to trigger a random event on cast.\"\"\"\n        if random.random() > 0.05:\n            return None\n\n        # Select a random event\n        available_events = []\n        for event_id, event in EVENTS.items():\n            # Check if event is location-restricted\n            if \"locations\" in event and location not in event[\"locations\"]:\n                continue\n            available_events.append((event_id, event))\n\n        if not available_events:\n            return None\n\n        event_id, event = random.choice(available_events)\n        expires = datetime.now(UTC) + timedelta(minutes=event[\"duration_minutes\"])\n\n        active_event = {\n            \"type\": event_id,\n            \"name\": event[\"name\"],\n            \"description\": event[\"description\"],\n            \"effect\": event.get(\"effect\"),\n            \"multiplier\": event.get(\"multiplier\", 1.0),\n            \"expires\": expires.isoformat(),\n            \"announced_channels\": [channel],\n        }\n\n        self.set_state(\"active_event\", active_event)\n        self.save_state()\n\n        return active_event\n\n    def _get_active_event(self, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get the currently active event if any and valid for location.\"\"\"\n        event = self.get_state(\"active_event\")\n        if not event:\n            return None\n\n        # Check if expired\n        expires = datetime.fromisoformat(event[\"expires\"])\n        if datetime.now(UTC) >= expires:\n            self.set_state(\"active_event\", None)\n            self.save_state()\n            return None\n\n        # Check location restriction\n        event_data = EVENTS.get(event[\"type\"], {})\n        if \"locations\" in event_data and location not in event_data[\"locations\"]:\n            return None\n\n        return event\n\n    def _get_water_boost(self, player: Dict[str, Any]) -> float:\n        \"\"\"Get the current water boost percentage (0.0 to 0.4 for 0% to 40%).\"\"\"\n        # Check if we need to reset daily counter\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        \n        if water_date != today:\n            # New day, reset counter\n            return 0.0\n        \n        # Each water bottle adds 10% boost, max 4 bottles = 40%\n        water_count = player.get(\"water_today\", 0)\n        return min(water_count * 0.10, 0.40)\n\n    def _cmd_cast(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if already has active cast\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you already have a line in the water at {cast['location']}! \"\n                f\"It's been {hours:.1f} hours. Use !reel to bring it in.\"\n            )\n            return True\n\n        player = self._get_player(user_id)\n        \n        # Check if location argument was provided\n        location_arg = match.group(1)\n        if location_arg:\n            # Try to find the requested location\n            requested_location = self._find_location_by_name(location_arg)\n            \n            if not requested_location:\n                # List all available locations\n                available_locs = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, location '{location_arg}' not found. \"\n                    f\"Available locations: {', '.join(available_locs)}\"\n                )\n                return True\n            \n            # Check if player has unlocked this location\n            if requested_location[\"level\"] > player[\"level\"]:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't unlocked {requested_location['name']} yet! \"\n                    f\"You need to be level {requested_location['level']} (currently level {player['level']}).\"\n                )\n                return True\n            \n            location = requested_location\n        else:\n            # No location specified, use current level's default location\n            location = self._get_location_for_level(player[\"level\"])\n        \n        distance = self._get_cast_distance(player[\"level\"], location)\n\n        # Record the cast\n        active_casts[user_id] = {\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"distance\": distance,\n            \"location\": location[\"name\"],\n            \"channel\": event.target,\n            \"allow_lower_fish\": not location_arg,\n        }\n        self.set_state(\"active_casts\", active_casts)\n\n        # Update player stats\n        player[\"total_casts\"] += 1\n        if distance > player[\"furthest_cast\"]:\n            player[\"furthest_cast\"] = distance\n        self._save_player(user_id, player)\n\n        # Check for event trigger\n        triggered_event = self._check_event_trigger(event.target, location[\"name\"])\n\n        # Send cast message\n        cast_msg = random.choice(CAST_MESSAGES).format(\n            distance=distance,\n            location=location[\"name\"]\n        )\n        self.safe_reply(connection, event, f\"{self.bot.title_for(username)}, {cast_msg}\")\n\n        # Announce event if triggered\n        if triggered_event:\n            self.safe_say(\n                f\"** {triggered_event['name']} ** - {triggered_event['description']}\",\n                target=event.target\n            )\n\n        return True\n\n    def _cmd_reel(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if has active cast\n        if user_id not in active_casts:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you don't have a line in the water. Use !cast first.\"\n            )\n            return True\n\n        cast = active_casts[user_id]\n        cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n        now = datetime.now(UTC)\n        elapsed = now - cast_time\n        wait_hours = elapsed.total_seconds() / 3600\n\n        location_name = cast[\"location\"]\n        location = next((l for l in LOCATIONS if l[\"name\"] == location_name), LOCATIONS[0])\n        player = self._get_player(user_id)\n        forced_rare_flag = player.get(\"force_rare_legendary\", False)\n\n        # Remove the cast\n        del active_casts[user_id]\n        self.set_state(\"active_casts\", active_casts)\n        self.save_state()\n\n        # Get active event\n        active_event = self._get_active_event(location_name)\n\n        # Apply time boost event if active\n        effective_wait = wait_hours\n        if active_event and active_event.get(\"effect\") == \"time_boost\":\n            effective_wait = wait_hours / active_event.get(\"multiplier\", 1.0)\n\n        # Too early - nothing caught\n        if effective_wait < self.MIN_WAIT_HOURS:\n            self.safe_reply(connection, event, random.choice(TOO_EARLY_MESSAGES))\n            return True\n\n        # Danger zone - chance of bad outcome\n        if wait_hours > self.DANGER_THRESHOLD_HOURS and not forced_rare_flag:\n            hours_over = wait_hours - self.DANGER_THRESHOLD_HOURS\n            bad_chance = min(0.1 + (hours_over * 0.05), 0.9)\n\n            if random.random() < bad_chance:\n                # Bad outcome\n                bad_type = random.choice([\"line_break\", \"fish_escaped\", \"junk\"])\n\n                if bad_type == \"line_break\":\n                    player[\"lines_broken\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"line_break\"])\n                    )\n                elif bad_type == \"fish_escaped\":\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"fish_escaped\"])\n                    )\n                else:  # junk\n                    junk = self._get_junk(location[\"type\"])\n                    player[\"junk_collected\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        f\"After waiting {wait_hours:.1f} hours, you reel in... {junk}. \"\n                        \"Maybe don't leave your line out so long next time.\"\n                    )\n                return True\n\n        # Junk check (base chance, boosted by murky waters)\n        if not forced_rare_flag:\n            junk_chance = 0.10\n            if active_event and active_event.get(\"effect\") == \"junk_boost\":\n                junk_chance *= active_event.get(\"multiplier\", 1.0)\n\n            if random.random() < junk_chance:\n                junk = self._get_junk(location[\"type\"])\n                player[\"junk_collected\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                xp_gain = 5  # Small XP for junk\n                player[\"xp\"] += xp_gain\n                self._save_player(user_id, player)\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)} reels in... {junk}. \"\n                    f\"Well, at least you're cleaning up! (+{xp_gain} XP)\"\n                )\n                return True\n\n        # Successful catch!\n        water_boost = self._get_water_boost(player)\n        rarity = self._select_rarity(effective_wait, active_event, water_boost)\n        eligible_locations = None\n        if cast.get(\"allow_lower_fish\"):\n            eligible_locations = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        fish = None\n        forced_rare = player.get(\"force_rare_legendary\", False)\n        forced_rare_applied = False\n        if forced_rare:\n            forced_rarities = [\"rare\", \"legendary\"]\n            random.shuffle(forced_rarities)\n            for forced in forced_rarities:\n                fish = self._select_fish(\n                    location_name,\n                    forced,\n                    eligible_locations,\n                    allow_fallback=False,\n                )\n                if fish:\n                    rarity = forced\n                    forced_rare_applied = True\n                    break\n\n        if not fish:\n            fish = self._select_fish(location_name, rarity, eligible_locations)\n\n        if not fish:\n            # Fallback - shouldn't happen\n            self.safe_reply(connection, event, \"The fish got away at the last moment!\")\n            return True\n\n        weight = self._calculate_weight(fish, effective_wait)\n\n        # Line break check - bigger fish = higher chance\n        if not forced_rare_applied:\n            break_chance = 0.02 + (weight / 1000) * 0.15\n            if random.random() < break_chance:\n                player[\"lines_broken\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                self.safe_reply(\n                    connection, event,\n                    f\"You feel a massive tug - it's a {fish['name']}! But the weight is too much... \"\n                    f\"SNAP! The line breaks! It got away...\"\n                )\n                return True\n\n        # Successful catch!\n        player[\"total_fish\"] += 1\n        if weight > player[\"biggest_fish\"]:\n            player[\"biggest_fish\"] = weight\n            player[\"biggest_fish_name\"] = fish[\"name\"]\n\n        if forced_rare_applied:\n            player[\"force_rare_legendary\"] = False\n\n        # Track catches (global)\n        catches = player.get(\"catches\", {})\n        catches[fish[\"name\"]] = catches.get(fish[\"name\"], 0) + 1\n        player[\"catches\"] = catches\n\n        # Track catches by location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        if location_name not in catches_by_location:\n            catches_by_location[location_name] = {}\n        catches_by_location[location_name][fish[\"name\"]] = catches_by_location[location_name].get(fish[\"name\"], 0) + 1\n        player[\"catches_by_location\"] = catches_by_location\n\n        # Track location\n        if location_name not in player.get(\"locations_fished\", []):\n            player.setdefault(\"locations_fished\", []).append(location_name)\n\n        # Track rare/legendary for aquarium\n        if rarity in (\"rare\", \"legendary\"):\n            rare_catches = player.get(\"rare_catches\", [])\n            rare_catches.append({\n                \"name\": fish[\"name\"],\n                \"weight\": weight,\n                \"rarity\": rarity,\n                \"location\": location_name,\n                \"caught_at\": now.isoformat(),\n            })\n            player[\"rare_catches\"] = rare_catches\n\n        # Calculate XP\n        base_xp = 10\n        rarity_mult = RARITY_XP_MULTIPLIER.get(rarity, 1)\n        weight_bonus = 1 + (weight / 50)\n        xp_gain = int(base_xp * rarity_mult * weight_bonus)\n\n        # Event XP boost\n        if active_event and active_event.get(\"effect\") == \"xp_boost\":\n            xp_gain = int(xp_gain * active_event.get(\"multiplier\", 1.0))\n\n        bonus_messages = []\n        boost_catches = player.get(\"xp_boost_catches\", 0)\n        if boost_catches > 0:\n            xp_gain = int(xp_gain * XP_BOOST_MULTIPLIER)\n            boost_catches -= 1\n            player[\"xp_boost_catches\"] = boost_catches\n            bonus_messages.append(f\"Rod boost! x{XP_BOOST_MULTIPLIER} XP.\")\n            if boost_catches == 0:\n                bonus_messages.append(\"The rod's glow fades.\")\n\n        extra_xp = 0\n        roll = random.random()\n        if roll < XP_BONUS_LARGE_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_LARGE_RANGE)\n            bonus_messages.append(f\"Treasure haul! +{extra_xp} XP.\")\n        elif roll < XP_BONUS_LARGE_CHANCE + XP_BONUS_SMALL_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_SMALL_RANGE)\n            bonus_messages.append(f\"Lucky find! +{extra_xp} XP.\")\n\n        if player.get(\"xp_boost_catches\", 0) == 0 and random.random() < XP_BOOST_ROD_CHANCE:\n            player[\"xp_boost_catches\"] = XP_BOOST_ROD_CATCHES\n            bonus_messages.append(\n                f\"You found a better rod! Next {XP_BOOST_ROD_CATCHES} catches give double XP.\"\n            )\n\n        total_xp = xp_gain + extra_xp\n        player[\"xp\"] += total_xp\n        self._save_player(user_id, player)\n\n        # Record achievements\n        achievement_hooks.record_achievement(self.bot, username, \"fish_caught\", 1)\n        if rarity == \"rare\":\n            achievement_hooks.record_achievement(self.bot, username, \"rare_fish_caught\", 1)\n        elif rarity == \"legendary\":\n            achievement_hooks.record_achievement(self.bot, username, \"legendary_fish_caught\", 1)\n\n        # Perfect wait achievement (18-24 hours)\n        if 18.0 <= wait_hours <= 24.0:\n            achievement_hooks.record_achievement(self.bot, username, \"perfect_waits\", 1)\n\n        # Check level up\n        new_level = self._check_level_up(user_id, player, username)\n\n        # Build response\n        rarity_prefix = \"\"\n        if rarity == \"uncommon\":\n            rarity_prefix = \"an uncommon \"\n        elif rarity == \"rare\":\n            rarity_prefix = \"a RARE \"\n        elif rarity == \"legendary\":\n            rarity_prefix = \"a LEGENDARY \"\n        else:\n            rarity_prefix = \"a \"\n\n        response = (\n            f\"{self.bot.title_for(username)} reels in {rarity_prefix}{fish['name']} \"\n            f\"weighing {weight:.2f} lbs after waiting {wait_hours:.1f} hours! (+{total_xp} XP)\"\n        )\n        if bonus_messages:\n            response += \" \" + \" \".join(bonus_messages)\n        if forced_rare_applied:\n            response += \" A rare blessing guides your catch.\"\n\n        if new_level:\n            new_location = self._get_location_for_level(new_level)\n            response += f\" LEVEL UP! You're now level {new_level} and can fish at {new_location['name']}!\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_fishing_bless(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        target = match.group(1).strip()\n        target_id = self.bot.get_user_id(target)\n        player = self._get_player(target_id)\n        player[\"force_rare_legendary\"] = True\n        self._save_player(target_id, player)\n\n        self.safe_reply(\n            connection,\n            event,\n            f\"{self.bot.title_for(target)}, your next catch will be rare or legendary.\"\n        )\n        return True\n\n    def _cmd_fishing_stats(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        location = self._get_location_for_level(player[\"level\"])\n\n        xp_needed = self._get_xp_for_level(player[\"level\"])\n        xp_progress = f\"{player['xp']}/{xp_needed}\"\n\n        stats = (\n            f\"Fishing Stats for {self.bot.title_for(username)}: \"\n            f\"Level {player['level']} ({location['name']}) | \"\n            f\"XP: {xp_progress} | \"\n            f\"Fish: {player['total_fish']} | \"\n            f\"Biggest: {player['biggest_fish']:.2f} lbs\"\n        )\n\n        if player.get(\"biggest_fish_name\"):\n            stats += f\" ({player['biggest_fish_name']})\"\n\n        stats += f\" | Casts: {player['total_casts']} | Junk: {player['junk_collected']}\"\n\n        self.safe_reply(connection, event, stats)\n        return True\n\n    def _cmd_fishing_top(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        players = self.get_state(\"players\", {})\n        if not players:\n            self.safe_reply(connection, event, \"No one has gone fishing yet!\")\n            return True\n\n        # Get user map for display names\n        user_map = self.bot.get_module_state(\"users\").get(\"user_map\", {})\n\n        # Top by total fish\n        by_fish = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"total_fish\", 0) > 0],\n            key=lambda x: x[1][\"total_fish\"],\n            reverse=True\n        )[:5]\n\n        # Top by biggest fish\n        by_size = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"biggest_fish\", 0) > 0],\n            key=lambda x: x[1][\"biggest_fish\"],\n            reverse=True\n        )[:5]\n\n        response_parts = [\"Fishing Leaderboards:\"]\n\n        if by_fish:\n            fish_list = []\n            for i, (uid, p) in enumerate(by_fish):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_list.append(f\"#{i+1} {name} ({p['total_fish']})\")\n            response_parts.append(\"Most Fish: \" + \", \".join(fish_list))\n\n        if by_size:\n            size_list = []\n            for i, (uid, p) in enumerate(by_size):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_name = p.get(\"biggest_fish_name\", \"fish\")\n                size_list.append(f\"#{i+1} {name} ({p['biggest_fish']:.1f} lbs - {fish_name})\")\n            response_parts.append(\"Biggest Catch: \" + \", \".join(size_list))\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishing_location(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        current_loc = self._get_location_for_level(player[\"level\"])\n\n        # Check for active cast\n        active_casts = self.get_state(\"active_casts\", {})\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}: Currently fishing at {cast['location']} \"\n                f\"(line out for {hours:.1f} hours). Level {player['level']}.\"\n            )\n            return True\n\n        # Build location progress\n        unlocked = [l for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        next_loc = next((l for l in LOCATIONS if l[\"level\"] > player[\"level\"]), None)\n\n        response = (\n            f\"{self.bot.title_for(username)}: Level {player['level']}, \"\n            f\"currently at {current_loc['name']}. \"\n            f\"Unlocked: {', '.join(l['name'] for l in unlocked)}.\"\n        )\n\n        if next_loc:\n            xp_needed = self._get_xp_for_level(player[\"level\"])\n            response += f\" Next: {next_loc['name']} at level {next_loc['level']} ({player['xp']}/{xp_needed} XP).\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_aquarium(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        rare_catches = player.get(\"rare_catches\", [])\n\n        if not rare_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}'s aquarium is empty. \"\n                \"Catch some rare or legendary fish to display them here!\"\n            )\n            return True\n\n        # Group by rarity\n        legendaries = [c for c in rare_catches if c[\"rarity\"] == \"legendary\"]\n        rares = [c for c in rare_catches if c[\"rarity\"] == \"rare\"]\n\n        response_parts = [f\"{self.bot.title_for(username)}'s Aquarium:\"]\n\n        if legendaries:\n            leg_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in legendaries[-5:]  # Last 5\n            )\n            response_parts.append(f\"LEGENDARY: {leg_display}\")\n\n        if rares:\n            rare_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in rares[-5:]  # Last 5\n            )\n            response_parts.append(f\"Rare: {rare_display}\")\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishinfo(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        \n        # Get location argument\n        location_arg = match.group(1)\n        \n        if not location_arg:\n            # No location specified - show available locations\n            locations_fished = player.get(\"locations_fished\", [])\n            if not locations_fished:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't caught any fish yet! \"\n                    \"Use !cast and !reel to start fishing.\"\n                )\n                return True\n            \n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, locations you've fished: {', '.join(locations_fished)}. \"\n                \"Use !fishinfo <location> to see fish caught there.\"\n            )\n            return True\n        \n        # Find the location\n        location = self._find_location_by_name(location_arg)\n        if not location:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, location '{location_arg}' not found.\"\n            )\n            return True\n        \n        location_name = location[\"name\"]\n        \n        # Get catches for this location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        location_catches = catches_by_location.get(location_name, {})\n        \n        if not location_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you haven't caught any fish at {location_name} yet!\"\n            )\n            return True\n        \n        # Get all fish available at this location for completion stats\n        all_fish = FISH_DATABASE.get(location_name, [])\n        total_species = len(all_fish)\n        caught_species = len(location_catches)\n        \n        # Group by rarity\n        caught_by_rarity = {\"common\": [], \"uncommon\": [], \"rare\": [], \"legendary\": []}\n        for fish_name, count in location_catches.items():\n            # Find the fish in the database to get its rarity\n            fish_data = next((f for f in all_fish if f[\"name\"] == fish_name), None)\n            if fish_data:\n                rarity = fish_data[\"rarity\"]\n                caught_by_rarity[rarity].append(f\"{fish_name} ({count})\")\n        \n        # Build response\n        total_caught = sum(location_catches.values())\n        response_parts = [\n            f\"{self.bot.title_for(username)}'s {location_name} catches: \"\n            f\"{total_caught} fish, {caught_species}/{total_species} species\"\n        ]\n        \n        # Add fish by rarity\n        for rarity in [\"legendary\", \"rare\", \"uncommon\", \"common\"]:\n            if caught_by_rarity[rarity]:\n                rarity_label = rarity.upper() if rarity in [\"legendary\", \"rare\"] else rarity.capitalize()\n                fish_list = \", \".join(caught_by_rarity[rarity])\n                response_parts.append(f\"{rarity_label}: {fish_list}\")\n        \n        # Send as multiple messages if too long\n        full_response = \" | \".join(response_parts)\n        if len(full_response) > 400:\n            # Send in parts\n            self.safe_reply(connection, event, response_parts[0])\n            for part in response_parts[1:]:\n                self.safe_say(part, target=event.target)\n        else:\n            self.safe_reply(connection, event, full_response)\n        \n        return True\n\n    def _cmd_fishing_help(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        help_lines = [\n            \"Fishing Commands:\",\n            \"!cast - Cast at your current level (can catch fish from any unlocked lower levels)\",\n            \"!cast <location> - Cast at a specific unlocked location (e.g., !cast pond)\",\n            \"!reel - Reel in your catch (wait 1-24 hours for best results)\",\n            \"!fishing - Show your stats\",\n            \"!fishing top - Leaderboards\",\n            \"!fishing location - Current location and level progress\",\n            \"!fishinfo - List locations you've fished\",\n            \"!fishinfo <location> - Show fish caught at a specific location (e.g., !fishinfo pond)\",\n            \"!aquarium - View your rare/legendary catches\",\n            \"!water - Celebrate finishing a water bottle (boosts rare fish, max 4/day)\",\n            \"\",\n            \"Tips: !cast pulls fish from your current level and any lower unlocked levels.\",\n            \"You can also travel back to previous locations to hunt for rare fish you missed!\",\n            \"Stay hydrated! Each bottle of water increases rare fish chances by 10% (up to 40%).\",\n        ]\n\n        for line in help_lines:\n            self.safe_privmsg(username, line)\n\n        self.safe_reply(\n            connection, event,\n            f\"{self.bot.title_for(username)}, I've sent you the fishing guide.\"\n        )\n        return True\n\n    def _cmd_water(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n\n        # Get today's date\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        water_count = player.get(\"water_today\", 0)\n\n        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check if they've already had 4 bottles today\n        if water_count >= 4:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you have already consumed your four bottles of water today! \"\n                \"Most commendable dedication to hydration. Do return tomorrow for further encouragement.\"\n            )\n            return True\n\n        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)\n\n        # Calculate new boost percentage\n        boost_percentage = water_count * 10\n\n        # Build response based on how many they've had\n        if water_count == 1:\n            response = (\n                f\"Splendid! {self.bot.title_for(username)}, I am delighted to see you tending to your hydration. \"\n                f\"Three more bottles to go! Your commitment to wellness grants you a {boost_percentage}% boost \"\n                \"to catching rare and legendary fish today.\"\n            )\n        elif water_count == 2:\n            response = (\n                f\"Excellent progress, {self.bot.title_for(username)}! Two bottles down, two more to go! \"\n                f\"Your dedication is most admirable. You now have a {boost_percentage}% boost to rare catches.\"\n            )\n        elif water_count == 3:\n            response = (\n                f\"Marvelous! {self.bot.title_for(username)}, just one more bottle remains! \"\n                f\"You are nearly at peak hydration. Current boost: {boost_percentage}% to rare and legendary fish.\"\n            )\n        else:  # water_count == 4\n            response = (\n                f\"Outstanding! {self.bot.title_for(username)}, you have completed your daily hydration goal! \"\n                f\"I am exceedingly proud of your commitment to health. You now enjoy a magnificent {boost_percentage}% \"\n                \"boost to catching rare and legendary fish for the remainder of the day!\"\n            )\n\n        self.safe_reply(connection, event, response)\n        return True\n","structuredPatch":[{"oldStart":421,"oldLines":6,"newStart":421,"newLines":7,"lines":["                 \"locations_fished\": [],","                 \"water_today\": 0,  # Number of water bottles consumed today","                 \"water_date\": None,  # Date of last water consumption (for daily reset)","+                \"water_last_used\": None,  # ISO timestamp of last !water command","                 \"xp_boost_catches\": 0,","                 \"force_rare_legendary\": False,","             }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"29412b1e-8d8b-4be6-8c08-7f0c3f2626e8"}
{"parentUuid":"bf84f49b-1df9-45a1-b8e9-e42c76a676b0","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_011FzuNDuQiFNsVW8qmuE49M","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the cooldown check and snarky responses in `_cmd_water`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":442,"cache_read_input_tokens":42597,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":442},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HiE2RYiURx84j7stzY","type":"assistant","uuid":"800a21c2-d47c-4fbd-9d84-88abc5046f79","timestamp":"2026-02-12T01:14:33.850Z"}
{"parentUuid":"800a21c2-d47c-4fbd-9d84-88abc5046f79","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_011FzuNDuQiFNsVW8qmuE49M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BtnRv3Q5PCnRWEZUKH6RoN","name":"Edit","input":{"replace_all":false,"file_path":"/home/nylan/code/jeeves/modules/fishing.py","old_string":"        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check if they've already had 4 bottles today","new_string":"        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check cooldown - must wait at least 1 hour between waters\n        water_last_used = player.get(\"water_last_used\")\n        if water_last_used and water_count > 0:\n            last_used_time = datetime.fromisoformat(water_last_used)\n            elapsed = datetime.now(UTC) - last_used_time\n            remaining_minutes = 60 - (elapsed.total_seconds() / 60)\n            if remaining_minutes > 0:\n                too_fast_messages = [\n                    (\n                        f\"I beg your pardon, {self.bot.title_for(username)}, but I find it rather difficult to believe \"\n                        f\"that you have consumed an entire bottle of water in {elapsed.total_seconds() / 60:.0f} minutes. \"\n                        f\"One does not wish to make accusations, but this has all the hallmarks of what I believe \"\n                        f\"the younger generation refers to as 'gaming the system.' Perhaps try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Most irregular, {self.bot.title_for(username)}. I have served in some of the finest households \"\n                        f\"in England, and I have never once witnessed a bottle of water dispatched with such supernatural haste. \"\n                        f\"Might I suggest actually drinking one? You may retry in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Forgive me, {self.bot.title_for(username)}, but unless you have developed gills — \"\n                        f\"which, while fascinating, seems improbable — I rather suspect this water bottle is purely theoretical. \"\n                        f\"The next hydration opportunity presents itself in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"I venture to observe, {self.bot.title_for(username)}, that the speed of your alleged consumption \"\n                        f\"would make even the most enthusiastic camel raise an eyebrow. One hesitates to use the word \"\n                        f\"'shenanigans,' but the evidence is compelling. Do try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                ]\n                self.safe_reply(connection, event, random.choice(too_fast_messages))\n                return True\n\n        # Check if they've already had 4 bottles today"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":442,"cache_read_input_tokens":42597,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":442},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HiE2RYiURx84j7stzY","type":"assistant","uuid":"600a7038-ac6c-4852-a23a-8370e8d9fa6e","timestamp":"2026-02-12T01:14:45.713Z"}
{"parentUuid":"600a7038-ac6c-4852-a23a-8370e8d9fa6e","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BtnRv3Q5PCnRWEZUKH6RoN","toolUseID":"toolu_01BtnRv3Q5PCnRWEZUKH6RoN","timestamp":"2026-02-12T01:15:55.588Z","uuid":"79d86588-7fc8-408f-b978-29d6a548d411"}
{"parentUuid":"600a7038-ac6c-4852-a23a-8370e8d9fa6e","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BtnRv3Q5PCnRWEZUKH6RoN","type":"tool_result","content":"The file /home/nylan/code/jeeves/modules/fishing.py has been updated successfully."}]},"uuid":"91913b37-fca1-4917-8dfb-5aa0c9a7bc9a","timestamp":"2026-02-12T01:15:55.588Z","toolUseResult":{"filePath":"/home/nylan/code/jeeves/modules/fishing.py","oldString":"        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check if they've already had 4 bottles today","newString":"        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check cooldown - must wait at least 1 hour between waters\n        water_last_used = player.get(\"water_last_used\")\n        if water_last_used and water_count > 0:\n            last_used_time = datetime.fromisoformat(water_last_used)\n            elapsed = datetime.now(UTC) - last_used_time\n            remaining_minutes = 60 - (elapsed.total_seconds() / 60)\n            if remaining_minutes > 0:\n                too_fast_messages = [\n                    (\n                        f\"I beg your pardon, {self.bot.title_for(username)}, but I find it rather difficult to believe \"\n                        f\"that you have consumed an entire bottle of water in {elapsed.total_seconds() / 60:.0f} minutes. \"\n                        f\"One does not wish to make accusations, but this has all the hallmarks of what I believe \"\n                        f\"the younger generation refers to as 'gaming the system.' Perhaps try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Most irregular, {self.bot.title_for(username)}. I have served in some of the finest households \"\n                        f\"in England, and I have never once witnessed a bottle of water dispatched with such supernatural haste. \"\n                        f\"Might I suggest actually drinking one? You may retry in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Forgive me, {self.bot.title_for(username)}, but unless you have developed gills — \"\n                        f\"which, while fascinating, seems improbable — I rather suspect this water bottle is purely theoretical. \"\n                        f\"The next hydration opportunity presents itself in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"I venture to observe, {self.bot.title_for(username)}, that the speed of your alleged consumption \"\n                        f\"would make even the most enthusiastic camel raise an eyebrow. One hesitates to use the word \"\n                        f\"'shenanigans,' but the evidence is compelling. Do try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                ]\n                self.safe_reply(connection, event, random.choice(too_fast_messages))\n                return True\n\n        # Check if they've already had 4 bottles today","originalFile":"# modules/fishing.py\n# A fishing mini-game where users cast lines and reel in catches over time.\n\nimport random\nimport re\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom .base import SimpleCommandModule\nfrom . import achievement_hooks\n\nUTC = timezone.utc\n\n\ndef setup(bot: Any) -> 'Fishing':\n    return Fishing(bot)\n\n\n# Fishing locations unlocked by level (0-9)\nLOCATIONS = [\n    {\"name\": \"Puddle\", \"level\": 0, \"max_distance\": 5, \"type\": \"terrestrial\"},\n    {\"name\": \"Pond\", \"level\": 1, \"max_distance\": 15, \"type\": \"terrestrial\"},\n    {\"name\": \"Lake\", \"level\": 2, \"max_distance\": 30, \"type\": \"terrestrial\"},\n    {\"name\": \"River\", \"level\": 3, \"max_distance\": 50, \"type\": \"terrestrial\"},\n    {\"name\": \"Ocean\", \"level\": 4, \"max_distance\": 100, \"type\": \"terrestrial\"},\n    {\"name\": \"Deep Sea\", \"level\": 5, \"max_distance\": 200, \"type\": \"terrestrial\"},\n    {\"name\": \"Moon\", \"level\": 6, \"max_distance\": 500, \"type\": \"space\"},\n    {\"name\": \"Mars\", \"level\": 7, \"max_distance\": 1000, \"type\": \"space\"},\n    {\"name\": \"Jupiter\", \"level\": 8, \"max_distance\": 2000, \"type\": \"space\"},\n    {\"name\": \"The Void\", \"level\": 9, \"max_distance\": 5000, \"type\": \"space\"},\n]\n\n# Fish database organized by location\n# Each fish has: name, min_weight, max_weight, rarity\nFISH_DATABASE: Dict[str, List[Dict[str, Any]]] = {\n    \"Puddle\": [\n        # Common\n        {\"name\": \"Minnow\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        {\"name\": \"Tadpole\", \"min_weight\": 0.05, \"max_weight\": 0.2, \"rarity\": \"common\"},\n        {\"name\": \"Guppy\", \"min_weight\": 0.1, \"max_weight\": 0.3, \"rarity\": \"common\"},\n        {\"name\": \"Water Beetle\", \"min_weight\": 0.01, \"max_weight\": 0.1, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Goldfish\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Small Frog\", \"min_weight\": 0.3, \"max_weight\": 1.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Koi\", \"min_weight\": 2.0, \"max_weight\": 5.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Puddle King\", \"min_weight\": 8.0, \"max_weight\": 15.0, \"rarity\": \"legendary\"},\n    ],\n    \"Pond\": [\n        # Common\n        {\"name\": \"Bluegill\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Perch\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Sunfish\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Crayfish\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Largemouth Bass\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Catfish\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Perch\", \"min_weight\": 5.0, \"max_weight\": 12.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Old Whiskers\", \"min_weight\": 20.0, \"max_weight\": 40.0, \"rarity\": \"legendary\"},\n    ],\n    \"Lake\": [\n        # Common\n        {\"name\": \"Trout\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Crappie\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Walleye\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Pike\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Lake Sturgeon\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Muskie\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Albino Sturgeon\", \"min_weight\": 20.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Nessie's Cousin\", \"min_weight\": 100.0, \"max_weight\": 200.0, \"rarity\": \"legendary\"},\n    ],\n    \"River\": [\n        # Common\n        {\"name\": \"Salmon\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Steelhead\", \"min_weight\": 4.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        {\"name\": \"River Carp\", \"min_weight\": 3.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Smallmouth Bass\", \"min_weight\": 2.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"King Salmon\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Paddlefish\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Salmon\", \"min_weight\": 25.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The River Guardian\", \"min_weight\": 80.0, \"max_weight\": 150.0, \"rarity\": \"legendary\"},\n    ],\n    \"Ocean\": [\n        # Common\n        {\"name\": \"Tuna\", \"min_weight\": 20.0, \"max_weight\": 80.0, \"rarity\": \"common\"},\n        {\"name\": \"Mackerel\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Sea Bass\", \"min_weight\": 10.0, \"max_weight\": 40.0, \"rarity\": \"common\"},\n        {\"name\": \"Flounder\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Swordfish\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Mahi-Mahi\", \"min_weight\": 15.0, \"max_weight\": 50.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Barracuda\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Blue Marlin\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Sailfish\", \"min_weight\": 80.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Moby Dick Jr.\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Deep Sea\": [\n        # Common\n        {\"name\": \"Anglerfish\", \"min_weight\": 5.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Viperfish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Gulper Eel\", \"min_weight\": 3.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Lanternfish\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Giant Squid\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Oarfish\", \"min_weight\": 30.0, \"max_weight\": 100.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Goblin Shark\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Colossal Squid\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Megamouth Shark\", \"min_weight\": 300.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Kraken\", \"min_weight\": 1000.0, \"max_weight\": 2500.0, \"rarity\": \"legendary\"},\n    ],\n    \"Moon\": [\n        # Common\n        {\"name\": \"Moon Jellyfish\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Lunar Shrimp\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Crater Minnow\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Dust Swimmer\", \"min_weight\": 1.0, \"max_weight\": 4.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Crater Crab\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Void Eel\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Selenite Fish\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Cosmic Whale\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        {\"name\": \"Starlight Serpent\", \"min_weight\": 40.0, \"max_weight\": 150.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Leviathan of Tranquility\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Mars\": [\n        # Common\n        {\"name\": \"Rust Minnow\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Red Silt Crawler\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Iron Guppy\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Dust Devil Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Olympus Bass\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Valles Trout\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Phobos Flounder\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Martian Kraken\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Red Planet Leviathan\", \"min_weight\": 150.0, \"max_weight\": 400.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Ancient One\", \"min_weight\": 1000.0, \"max_weight\": 2000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Jupiter\": [\n        # Common\n        {\"name\": \"Gas Giant Jellyfish\", \"min_weight\": 2.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Storm Swimmer\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Ammonia Minnow\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Cloud Drifter\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Red Spot Ray\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Ammonia Eel\", \"min_weight\": 30.0, \"max_weight\": 80.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Io Salmon\", \"min_weight\": 25.0, \"max_weight\": 70.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Jovian Leviathan\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Europa Ice Beast\", \"min_weight\": 250.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Great Red Serpent\", \"min_weight\": 2000.0, \"max_weight\": 4000.0, \"rarity\": \"legendary\"},\n    ],\n    \"The Void\": [\n        # Common\n        {\"name\": \"Void Mite\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Dark Matter Shrimp\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Null Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Entropy Minnow\", \"min_weight\": 1.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Entropy Eel\", \"min_weight\": 25.0, \"max_weight\": 75.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Singularity Squid\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Dimensional Drifter\", \"min_weight\": 40.0, \"max_weight\": 120.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Reality Warper\", \"min_weight\": 300.0, \"max_weight\": 800.0, \"rarity\": \"rare\"},\n        {\"name\": \"Event Horizon Eel\", \"min_weight\": 400.0, \"max_weight\": 900.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Cosmic Horror\", \"min_weight\": 5000.0, \"max_weight\": 10000.0, \"rarity\": \"legendary\"},\n        {\"name\": \"Cthulhu's Cousin\", \"min_weight\": 8000.0, \"max_weight\": 15000.0, \"rarity\": \"legendary\"},\n    ],\n}\n\n# Junk items by location type\nJUNK_ITEMS: Dict[str, List[str]] = {\n    \"terrestrial\": [\n        \"Old Boot\", \"Rusty Tin Can\", \"Soggy Newspaper\", \"Tangled Fishing Line\",\n        \"Broken Sunglasses\", \"Waterlogged Book\", \"Deflated Beach Ball\", \"Lost Flip-Flop\",\n        \"Shopping Cart Wheel\", \"Plastic Bottle\", \"Tire\", \"Underwear\", \"License Plate\",\n        \"Broken Umbrella\", \"Moldy Wallet\", \"Damp Cigarette Pack\", \"Fishing Bobber\",\n        \"Knitting Needle\", \"Crochet Hook\", \"Tangled Yarn Ball\", \"Stitch Marker\",\n        \"Frayed Crochet Bag\", \"Half-Finished Scarf\", \"Pattern Printout\",\n        \"Game Controller\", \"Pixelated Cartridge\", \"Arcade Token\", \"Headset Mic\",\n        \"Trophy Cup\", \"Resistance Band\", \"Kettlebell\", \"Gym Towel\",\n        \"Protein Shaker\", \"Yoga Mat\", \"Jump Rope\",\n    ],\n    \"space\": [\n        \"Space Debris\", \"Frozen Oxygen Chunk\", \"Abandoned Satellite\", \"Lost Astronaut Glove\",\n        \"Alien Artifact\", \"Meteor Fragment\", \"Cosmic Dust Bunny\", \"Derelict Probe\",\n        \"Ancient Star Map\", \"Fossilized Moonrock\", \"Mysterious Orb\", \"Quantum Fluctuation\",\n        \"Void Crystal\", \"Broken Warp Core\", \"Lost Space Buoy\", \"Crystallized Stardust\",\n        \"Zero-G Yarn Ball\", \"Starlight Crochet Hook\", \"Orbital Knitting Needle\",\n        \"Cosmic Game Controller\", \"Nebula Cartridge\", \"Warped Arcade Token\",\n        \"Anti-Gravity Kettlebell\", \"Meteorite Dumbbell\", \"Vacuum-Sealed Gym Towel\",\n        \"Protein Paste Packet\", \"Quantum Jump Rope\",\n    ],\n}\n\n# Random events that can trigger\nEVENTS: Dict[str, Dict[str, Any]] = {\n    \"full_moon\": {\n        \"name\": \"Full Moon\",\n        \"description\": \"The full moon rises! Rare fish are more active.\",\n        \"effect\": \"rare_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 30,\n    },\n    \"solar_flare\": {\n        \"name\": \"Solar Flare\",\n        \"description\": \"A solar flare energizes the waters! Double XP!\",\n        \"effect\": \"xp_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n    \"feeding_frenzy\": {\n        \"name\": \"Feeding Frenzy\",\n        \"description\": \"The fish are hungry! Catches are easier.\",\n        \"effect\": \"time_boost\",\n        \"multiplier\": 0.5,  # Halves effective required time\n        \"duration_minutes\": 25,\n    },\n    \"murky_waters\": {\n        \"name\": \"Murky Waters\",\n        \"description\": \"The waters are murky... more junk than usual.\",\n        \"effect\": \"junk_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 15,\n    },\n    \"meteor_shower\": {\n        \"name\": \"Meteor Shower\",\n        \"description\": \"A meteor shower brings strange creatures from beyond!\",\n        \"effect\": \"alien_fish\",\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n}\n\n# Rarity weights for fish selection\nRARITY_WEIGHTS = {\n    \"common\": 70,\n    \"uncommon\": 20,\n    \"rare\": 8,\n    \"legendary\": 2,\n}\n\n# XP multipliers by rarity\nRARITY_XP_MULTIPLIER = {\n    \"common\": 1,\n    \"uncommon\": 2,\n    \"rare\": 5,\n    \"legendary\": 20,\n}\n\n# XP bonus chances (per successful catch)\nXP_BONUS_SMALL_CHANCE = 0.04\nXP_BONUS_LARGE_CHANCE = 0.01\nXP_BOOST_ROD_CHANCE = 0.007\nXP_BOOST_ROD_CATCHES = 5\nXP_BOOST_MULTIPLIER = 2\nXP_BONUS_SMALL_RANGE = (8, 20)\nXP_BONUS_LARGE_RANGE = (40, 90)\n\n# Cast flavor messages\nCAST_MESSAGES = [\n    \"You cast your line, it goes {distance}m and floats quietly...\",\n    \"With a practiced flick, your line sails {distance}m into the {location}.\",\n    \"Your line arcs gracefully, landing {distance}m away in the {location}.\",\n    \"The line whips through the air, settling {distance}m out.\",\n    \"You send your line sailing {distance}m. Now we wait...\",\n]\n\n# Reel too early messages\nTOO_EARLY_MESSAGES = [\n    \"You reel in too soon - the line is empty. Perhaps patience is a virtue?\",\n    \"Nothing but an empty hook. The fish need more time to find your bait.\",\n    \"Your line comes back bare. Try waiting a bit longer next time.\",\n    \"Too hasty! The fish haven't even noticed your bait yet.\",\n    \"An empty catch. Good things come to those who wait.\",\n]\n\n# Danger zone messages (over 24 hours)\nDANGER_ZONE_MESSAGES = {\n    \"line_break\": [\n        \"The line finally snaps from the strain! It was out there too long.\",\n        \"Your line, weakened by time, breaks as you try to reel in.\",\n        \"The elements have taken their toll - your line breaks clean off!\",\n    ],\n    \"fish_escaped\": [\n        \"The fish got tired of waiting and swam away ages ago.\",\n        \"Whatever was on the line has long since escaped.\",\n        \"You reel in... nothing. The fish left hours ago.\",\n    ],\n    \"junk\": [\n        \"After all that time, you only catch some waterlogged junk.\",\n        \"The long wait rewards you with... garbage. How fitting.\",\n    ],\n}\n\n\nclass Fishing(SimpleCommandModule):\n    name = \"fishing\"\n    version = \"1.0.0\"\n    description = \"A fishing mini-game with locations, leveling, and rare catches.\"\n\n    # Time thresholds in hours\n    MIN_WAIT_HOURS = 1.0\n    OPTIMAL_WAIT_HOURS = 24.0\n    DANGER_THRESHOLD_HOURS = 24.0\n    MAX_DANGER_HOURS = 48.0\n\n    def __init__(self, bot: Any) -> None:\n        super().__init__(bot)\n\n        # Initialize state\n        if not self.get_state(\"active_casts\"):\n            self.set_state(\"active_casts\", {})\n        if not self.get_state(\"players\"):\n            self.set_state(\"players\", {})\n        if not self.get_state(\"active_event\"):\n            self.set_state(\"active_event\", None)\n        self.save_state()\n\n    def _register_commands(self) -> None:\n        self.register_command(\n            r'^\\s*!cast(?:\\s+(.+))?\\s*$',\n            self._cmd_cast,\n            name=\"cast\",\n            description=\"Cast your fishing line (optionally specify location)\"\n        )\n        self.register_command(\n            r'^\\s*!reel\\s*$',\n            self._cmd_reel,\n            name=\"reel\",\n            description=\"Reel in your catch\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing|stats)?\\s*$',\n            self._cmd_fishing_stats,\n            name=\"fishing\",\n            description=\"Show your fishing statistics\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+top\\s*$',\n            self._cmd_fishing_top,\n            name=\"fishing top\",\n            description=\"Show fishing leaderboards\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+location\\s*$',\n            self._cmd_fishing_location,\n            name=\"fishing location\",\n            description=\"Show your current fishing location\"\n        )\n        self.register_command(\n            r'^\\s*!fishinfo(?:\\s+(.+))?\\s*$',\n            self._cmd_fishinfo,\n            name=\"fishinfo\",\n            description=\"Show fish caught in a specific location\"\n        )\n        self.register_command(\n            r'^\\s*!aquarium\\s*$',\n            self._cmd_aquarium,\n            name=\"aquarium\",\n            description=\"Show your rare and legendary catches\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+help\\s*$',\n            self._cmd_fishing_help,\n            name=\"fishing help\",\n            description=\"Show fishing help\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+bless\\s+(\\S+)\\s*$',\n            self._cmd_fishing_bless,\n            name=\"fishing bless\",\n            admin_only=True,\n            description=\"[Admin] Guarantee a user's next catch is rare or legendary\"\n        )\n        self.register_command(\n            r'^\\s*!water\\s*$',\n            self._cmd_water,\n            name=\"water\",\n            description=\"Celebrate finishing a water bottle (boosts rare fish chances)\"\n        )\n\n    def _get_player(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Get or create a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        if user_id not in players:\n            players[user_id] = {\n                \"level\": 0,\n                \"xp\": 0,\n                \"total_fish\": 0,\n                \"biggest_fish\": 0.0,\n                \"biggest_fish_name\": None,\n                \"total_casts\": 0,\n                \"furthest_cast\": 0.0,\n                \"lines_broken\": 0,\n                \"junk_collected\": 0,\n                \"catches\": {},\n                \"catches_by_location\": {},  # {\"location_name\": {\"fish_name\": count}}\n                \"rare_catches\": [],\n                \"locations_fished\": [],\n                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"water_last_used\": None,  # ISO timestamp of last !water command\n                \"xp_boost_catches\": 0,\n                \"force_rare_legendary\": False,\n            }\n            self.set_state(\"players\", players)\n            self.save_state()\n        return players[user_id]\n\n    def _save_player(self, user_id: str, player: Dict[str, Any]) -> None:\n        \"\"\"Save a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        players[user_id] = player\n        self.set_state(\"players\", players)\n        self.save_state()\n\n    def _get_location_for_level(self, level: int) -> Dict[str, Any]:\n        \"\"\"Get the location a player can fish at based on their level.\"\"\"\n        # Player fishes at their max unlocked location\n        for loc in reversed(LOCATIONS):\n            if loc[\"level\"] <= level:\n                return loc\n        return LOCATIONS[0]\n\n    def _find_location_by_name(self, location_query: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Find a location by name (case-insensitive, supports partial matches).\"\"\"\n        query = location_query.strip().lower()\n        \n        # Try exact match first\n        for loc in LOCATIONS:\n            if loc[\"name\"].lower() == query:\n                return loc\n        \n        # Try partial match\n        for loc in LOCATIONS:\n            if query in loc[\"name\"].lower():\n                return loc\n        \n        return None\n\n    def _get_xp_for_level(self, level: int) -> int:\n        \"\"\"Calculate XP needed for a level.\"\"\"\n        return int(100 * ((level + 1) ** 1.5))\n\n    def _check_level_up(self, user_id: str, player: Dict[str, Any], username: str) -> Optional[int]:\n        \"\"\"Check if player leveled up, return new level if so.\"\"\"\n        current_level = player[\"level\"]\n        xp = player[\"xp\"]\n\n        while current_level < 9:  # Max level is 9\n            xp_needed = self._get_xp_for_level(current_level)\n            if xp >= xp_needed:\n                xp -= xp_needed\n                current_level += 1\n            else:\n                break\n\n        if current_level > player[\"level\"]:\n            player[\"level\"] = current_level\n            player[\"xp\"] = xp\n            self._save_player(user_id, player)\n            # Record achievement progress\n            achievement_hooks.record_fishing_level(self.bot, username, current_level)\n            return current_level\n\n        player[\"xp\"] = xp\n        return None\n\n    def _get_cast_distance(self, level: int, location: Dict[str, Any]) -> float:\n        \"\"\"Generate a random cast distance based on level and location.\"\"\"\n        max_dist = location[\"max_distance\"]\n        # Base distance is 30-70% of max, with level adding potential\n        min_dist = max_dist * 0.3\n        level_bonus = (level / 9) * 0.3  # Up to 30% bonus at max level\n        base_max = max_dist * (0.7 + level_bonus)\n        return round(random.uniform(min_dist, base_max), 1)\n\n    def _select_rarity(self, wait_hours: float, event: Optional[Dict[str, Any]] = None, water_boost: float = 0.0) -> str:\n        \"\"\"Select a rarity tier based on wait time, active events, and hydration boost.\"\"\"\n        weights = RARITY_WEIGHTS.copy()\n\n        # Adjust weights based on wait time\n        # < 6 hours: only common really\n        # 6-12: uncommon possible\n        # 12-18: rare possible\n        # 18-24: legendary possible\n\n        if wait_hours < 6:\n            weights[\"uncommon\"] = 5\n            weights[\"rare\"] = 0\n            weights[\"legendary\"] = 0\n        elif wait_hours < 12:\n            weights[\"rare\"] = 2\n            weights[\"legendary\"] = 0\n        elif wait_hours < 18:\n            weights[\"legendary\"] = 0\n        # else: full weights at 18+ hours\n\n        # Apply event bonuses\n        if event and event.get(\"effect\") == \"rare_boost\":\n            weights[\"rare\"] = int(weights[\"rare\"] * event.get(\"multiplier\", 1))\n            weights[\"legendary\"] = int(weights[\"legendary\"] * event.get(\"multiplier\", 1))\n\n        # Apply water boost (increases rare and legendary chances)\n        if water_boost > 0:\n            # Reduce common weight by the boost percentage\n            common_reduction = weights[\"common\"] * water_boost\n            weights[\"common\"] = max(1, int(weights[\"common\"] - common_reduction))\n            \n            # Distribute the reduction to rare and legendary\n            weights[\"rare\"] = int(weights[\"rare\"] + common_reduction * 0.6)\n            weights[\"legendary\"] = int(weights[\"legendary\"] + common_reduction * 0.4)\n\n        # Weighted random selection\n        total = sum(weights.values())\n        roll = random.randint(1, total)\n        cumulative = 0\n        for rarity, weight in weights.items():\n            cumulative += weight\n            if roll <= cumulative:\n                return rarity\n        return \"common\"\n\n    def _select_fish(\n        self,\n        location: str,\n        rarity: str,\n        eligible_locations: Optional[List[str]] = None,\n        allow_fallback: bool = True,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Select a fish from the eligible location pools matching the rarity.\"\"\"\n        if eligible_locations:\n            fish_pool = []\n            for loc_name in eligible_locations:\n                fish_pool.extend(FISH_DATABASE.get(loc_name, []))\n        else:\n            fish_pool = FISH_DATABASE.get(location, [])\n        matching = [f for f in fish_pool if f[\"rarity\"] == rarity]\n        if not matching and allow_fallback:\n            # Fall back to common if no fish of that rarity\n            matching = [f for f in fish_pool if f[\"rarity\"] == \"common\"]\n        if not matching:\n            return None\n        return random.choice(matching)\n\n    def _calculate_weight(self, fish: Dict[str, Any], wait_hours: float) -> float:\n        \"\"\"Calculate actual fish weight based on wait time.\"\"\"\n        min_w = fish[\"min_weight\"]\n        max_w = fish[\"max_weight\"]\n\n        # Weight scales with wait time up to 24 hours\n        time_factor = min(wait_hours / self.OPTIMAL_WAIT_HOURS, 1.0)\n\n        # Random variance within the range, biased by time factor\n        base_weight = min_w + (max_w - min_w) * time_factor\n        variance = (max_w - min_w) * 0.2  # 20% variance\n        weight = base_weight + random.uniform(-variance, variance)\n\n        return round(max(min_w, min(max_w, weight)), 2)\n\n    def _get_junk(self, location_type: str) -> str:\n        \"\"\"Get a random junk item.\"\"\"\n        items = JUNK_ITEMS.get(location_type, JUNK_ITEMS[\"terrestrial\"])\n        return random.choice(items)\n\n    def _check_event_trigger(self, channel: str, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"5% chance to trigger a random event on cast.\"\"\"\n        if random.random() > 0.05:\n            return None\n\n        # Select a random event\n        available_events = []\n        for event_id, event in EVENTS.items():\n            # Check if event is location-restricted\n            if \"locations\" in event and location not in event[\"locations\"]:\n                continue\n            available_events.append((event_id, event))\n\n        if not available_events:\n            return None\n\n        event_id, event = random.choice(available_events)\n        expires = datetime.now(UTC) + timedelta(minutes=event[\"duration_minutes\"])\n\n        active_event = {\n            \"type\": event_id,\n            \"name\": event[\"name\"],\n            \"description\": event[\"description\"],\n            \"effect\": event.get(\"effect\"),\n            \"multiplier\": event.get(\"multiplier\", 1.0),\n            \"expires\": expires.isoformat(),\n            \"announced_channels\": [channel],\n        }\n\n        self.set_state(\"active_event\", active_event)\n        self.save_state()\n\n        return active_event\n\n    def _get_active_event(self, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get the currently active event if any and valid for location.\"\"\"\n        event = self.get_state(\"active_event\")\n        if not event:\n            return None\n\n        # Check if expired\n        expires = datetime.fromisoformat(event[\"expires\"])\n        if datetime.now(UTC) >= expires:\n            self.set_state(\"active_event\", None)\n            self.save_state()\n            return None\n\n        # Check location restriction\n        event_data = EVENTS.get(event[\"type\"], {})\n        if \"locations\" in event_data and location not in event_data[\"locations\"]:\n            return None\n\n        return event\n\n    def _get_water_boost(self, player: Dict[str, Any]) -> float:\n        \"\"\"Get the current water boost percentage (0.0 to 0.4 for 0% to 40%).\"\"\"\n        # Check if we need to reset daily counter\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        \n        if water_date != today:\n            # New day, reset counter\n            return 0.0\n        \n        # Each water bottle adds 10% boost, max 4 bottles = 40%\n        water_count = player.get(\"water_today\", 0)\n        return min(water_count * 0.10, 0.40)\n\n    def _cmd_cast(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if already has active cast\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you already have a line in the water at {cast['location']}! \"\n                f\"It's been {hours:.1f} hours. Use !reel to bring it in.\"\n            )\n            return True\n\n        player = self._get_player(user_id)\n        \n        # Check if location argument was provided\n        location_arg = match.group(1)\n        if location_arg:\n            # Try to find the requested location\n            requested_location = self._find_location_by_name(location_arg)\n            \n            if not requested_location:\n                # List all available locations\n                available_locs = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, location '{location_arg}' not found. \"\n                    f\"Available locations: {', '.join(available_locs)}\"\n                )\n                return True\n            \n            # Check if player has unlocked this location\n            if requested_location[\"level\"] > player[\"level\"]:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't unlocked {requested_location['name']} yet! \"\n                    f\"You need to be level {requested_location['level']} (currently level {player['level']}).\"\n                )\n                return True\n            \n            location = requested_location\n        else:\n            # No location specified, use current level's default location\n            location = self._get_location_for_level(player[\"level\"])\n        \n        distance = self._get_cast_distance(player[\"level\"], location)\n\n        # Record the cast\n        active_casts[user_id] = {\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"distance\": distance,\n            \"location\": location[\"name\"],\n            \"channel\": event.target,\n            \"allow_lower_fish\": not location_arg,\n        }\n        self.set_state(\"active_casts\", active_casts)\n\n        # Update player stats\n        player[\"total_casts\"] += 1\n        if distance > player[\"furthest_cast\"]:\n            player[\"furthest_cast\"] = distance\n        self._save_player(user_id, player)\n\n        # Check for event trigger\n        triggered_event = self._check_event_trigger(event.target, location[\"name\"])\n\n        # Send cast message\n        cast_msg = random.choice(CAST_MESSAGES).format(\n            distance=distance,\n            location=location[\"name\"]\n        )\n        self.safe_reply(connection, event, f\"{self.bot.title_for(username)}, {cast_msg}\")\n\n        # Announce event if triggered\n        if triggered_event:\n            self.safe_say(\n                f\"** {triggered_event['name']} ** - {triggered_event['description']}\",\n                target=event.target\n            )\n\n        return True\n\n    def _cmd_reel(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if has active cast\n        if user_id not in active_casts:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you don't have a line in the water. Use !cast first.\"\n            )\n            return True\n\n        cast = active_casts[user_id]\n        cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n        now = datetime.now(UTC)\n        elapsed = now - cast_time\n        wait_hours = elapsed.total_seconds() / 3600\n\n        location_name = cast[\"location\"]\n        location = next((l for l in LOCATIONS if l[\"name\"] == location_name), LOCATIONS[0])\n        player = self._get_player(user_id)\n        forced_rare_flag = player.get(\"force_rare_legendary\", False)\n\n        # Remove the cast\n        del active_casts[user_id]\n        self.set_state(\"active_casts\", active_casts)\n        self.save_state()\n\n        # Get active event\n        active_event = self._get_active_event(location_name)\n\n        # Apply time boost event if active\n        effective_wait = wait_hours\n        if active_event and active_event.get(\"effect\") == \"time_boost\":\n            effective_wait = wait_hours / active_event.get(\"multiplier\", 1.0)\n\n        # Too early - nothing caught\n        if effective_wait < self.MIN_WAIT_HOURS:\n            self.safe_reply(connection, event, random.choice(TOO_EARLY_MESSAGES))\n            return True\n\n        # Danger zone - chance of bad outcome\n        if wait_hours > self.DANGER_THRESHOLD_HOURS and not forced_rare_flag:\n            hours_over = wait_hours - self.DANGER_THRESHOLD_HOURS\n            bad_chance = min(0.1 + (hours_over * 0.05), 0.9)\n\n            if random.random() < bad_chance:\n                # Bad outcome\n                bad_type = random.choice([\"line_break\", \"fish_escaped\", \"junk\"])\n\n                if bad_type == \"line_break\":\n                    player[\"lines_broken\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"line_break\"])\n                    )\n                elif bad_type == \"fish_escaped\":\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"fish_escaped\"])\n                    )\n                else:  # junk\n                    junk = self._get_junk(location[\"type\"])\n                    player[\"junk_collected\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        f\"After waiting {wait_hours:.1f} hours, you reel in... {junk}. \"\n                        \"Maybe don't leave your line out so long next time.\"\n                    )\n                return True\n\n        # Junk check (base chance, boosted by murky waters)\n        if not forced_rare_flag:\n            junk_chance = 0.10\n            if active_event and active_event.get(\"effect\") == \"junk_boost\":\n                junk_chance *= active_event.get(\"multiplier\", 1.0)\n\n            if random.random() < junk_chance:\n                junk = self._get_junk(location[\"type\"])\n                player[\"junk_collected\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                xp_gain = 5  # Small XP for junk\n                player[\"xp\"] += xp_gain\n                self._save_player(user_id, player)\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)} reels in... {junk}. \"\n                    f\"Well, at least you're cleaning up! (+{xp_gain} XP)\"\n                )\n                return True\n\n        # Successful catch!\n        water_boost = self._get_water_boost(player)\n        rarity = self._select_rarity(effective_wait, active_event, water_boost)\n        eligible_locations = None\n        if cast.get(\"allow_lower_fish\"):\n            eligible_locations = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        fish = None\n        forced_rare = player.get(\"force_rare_legendary\", False)\n        forced_rare_applied = False\n        if forced_rare:\n            forced_rarities = [\"rare\", \"legendary\"]\n            random.shuffle(forced_rarities)\n            for forced in forced_rarities:\n                fish = self._select_fish(\n                    location_name,\n                    forced,\n                    eligible_locations,\n                    allow_fallback=False,\n                )\n                if fish:\n                    rarity = forced\n                    forced_rare_applied = True\n                    break\n\n        if not fish:\n            fish = self._select_fish(location_name, rarity, eligible_locations)\n\n        if not fish:\n            # Fallback - shouldn't happen\n            self.safe_reply(connection, event, \"The fish got away at the last moment!\")\n            return True\n\n        weight = self._calculate_weight(fish, effective_wait)\n\n        # Line break check - bigger fish = higher chance\n        if not forced_rare_applied:\n            break_chance = 0.02 + (weight / 1000) * 0.15\n            if random.random() < break_chance:\n                player[\"lines_broken\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                self.safe_reply(\n                    connection, event,\n                    f\"You feel a massive tug - it's a {fish['name']}! But the weight is too much... \"\n                    f\"SNAP! The line breaks! It got away...\"\n                )\n                return True\n\n        # Successful catch!\n        player[\"total_fish\"] += 1\n        if weight > player[\"biggest_fish\"]:\n            player[\"biggest_fish\"] = weight\n            player[\"biggest_fish_name\"] = fish[\"name\"]\n\n        if forced_rare_applied:\n            player[\"force_rare_legendary\"] = False\n\n        # Track catches (global)\n        catches = player.get(\"catches\", {})\n        catches[fish[\"name\"]] = catches.get(fish[\"name\"], 0) + 1\n        player[\"catches\"] = catches\n\n        # Track catches by location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        if location_name not in catches_by_location:\n            catches_by_location[location_name] = {}\n        catches_by_location[location_name][fish[\"name\"]] = catches_by_location[location_name].get(fish[\"name\"], 0) + 1\n        player[\"catches_by_location\"] = catches_by_location\n\n        # Track location\n        if location_name not in player.get(\"locations_fished\", []):\n            player.setdefault(\"locations_fished\", []).append(location_name)\n\n        # Track rare/legendary for aquarium\n        if rarity in (\"rare\", \"legendary\"):\n            rare_catches = player.get(\"rare_catches\", [])\n            rare_catches.append({\n                \"name\": fish[\"name\"],\n                \"weight\": weight,\n                \"rarity\": rarity,\n                \"location\": location_name,\n                \"caught_at\": now.isoformat(),\n            })\n            player[\"rare_catches\"] = rare_catches\n\n        # Calculate XP\n        base_xp = 10\n        rarity_mult = RARITY_XP_MULTIPLIER.get(rarity, 1)\n        weight_bonus = 1 + (weight / 50)\n        xp_gain = int(base_xp * rarity_mult * weight_bonus)\n\n        # Event XP boost\n        if active_event and active_event.get(\"effect\") == \"xp_boost\":\n            xp_gain = int(xp_gain * active_event.get(\"multiplier\", 1.0))\n\n        bonus_messages = []\n        boost_catches = player.get(\"xp_boost_catches\", 0)\n        if boost_catches > 0:\n            xp_gain = int(xp_gain * XP_BOOST_MULTIPLIER)\n            boost_catches -= 1\n            player[\"xp_boost_catches\"] = boost_catches\n            bonus_messages.append(f\"Rod boost! x{XP_BOOST_MULTIPLIER} XP.\")\n            if boost_catches == 0:\n                bonus_messages.append(\"The rod's glow fades.\")\n\n        extra_xp = 0\n        roll = random.random()\n        if roll < XP_BONUS_LARGE_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_LARGE_RANGE)\n            bonus_messages.append(f\"Treasure haul! +{extra_xp} XP.\")\n        elif roll < XP_BONUS_LARGE_CHANCE + XP_BONUS_SMALL_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_SMALL_RANGE)\n            bonus_messages.append(f\"Lucky find! +{extra_xp} XP.\")\n\n        if player.get(\"xp_boost_catches\", 0) == 0 and random.random() < XP_BOOST_ROD_CHANCE:\n            player[\"xp_boost_catches\"] = XP_BOOST_ROD_CATCHES\n            bonus_messages.append(\n                f\"You found a better rod! Next {XP_BOOST_ROD_CATCHES} catches give double XP.\"\n            )\n\n        total_xp = xp_gain + extra_xp\n        player[\"xp\"] += total_xp\n        self._save_player(user_id, player)\n\n        # Record achievements\n        achievement_hooks.record_achievement(self.bot, username, \"fish_caught\", 1)\n        if rarity == \"rare\":\n            achievement_hooks.record_achievement(self.bot, username, \"rare_fish_caught\", 1)\n        elif rarity == \"legendary\":\n            achievement_hooks.record_achievement(self.bot, username, \"legendary_fish_caught\", 1)\n\n        # Perfect wait achievement (18-24 hours)\n        if 18.0 <= wait_hours <= 24.0:\n            achievement_hooks.record_achievement(self.bot, username, \"perfect_waits\", 1)\n\n        # Check level up\n        new_level = self._check_level_up(user_id, player, username)\n\n        # Build response\n        rarity_prefix = \"\"\n        if rarity == \"uncommon\":\n            rarity_prefix = \"an uncommon \"\n        elif rarity == \"rare\":\n            rarity_prefix = \"a RARE \"\n        elif rarity == \"legendary\":\n            rarity_prefix = \"a LEGENDARY \"\n        else:\n            rarity_prefix = \"a \"\n\n        response = (\n            f\"{self.bot.title_for(username)} reels in {rarity_prefix}{fish['name']} \"\n            f\"weighing {weight:.2f} lbs after waiting {wait_hours:.1f} hours! (+{total_xp} XP)\"\n        )\n        if bonus_messages:\n            response += \" \" + \" \".join(bonus_messages)\n        if forced_rare_applied:\n            response += \" A rare blessing guides your catch.\"\n\n        if new_level:\n            new_location = self._get_location_for_level(new_level)\n            response += f\" LEVEL UP! You're now level {new_level} and can fish at {new_location['name']}!\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_fishing_bless(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        target = match.group(1).strip()\n        target_id = self.bot.get_user_id(target)\n        player = self._get_player(target_id)\n        player[\"force_rare_legendary\"] = True\n        self._save_player(target_id, player)\n\n        self.safe_reply(\n            connection,\n            event,\n            f\"{self.bot.title_for(target)}, your next catch will be rare or legendary.\"\n        )\n        return True\n\n    def _cmd_fishing_stats(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        location = self._get_location_for_level(player[\"level\"])\n\n        xp_needed = self._get_xp_for_level(player[\"level\"])\n        xp_progress = f\"{player['xp']}/{xp_needed}\"\n\n        stats = (\n            f\"Fishing Stats for {self.bot.title_for(username)}: \"\n            f\"Level {player['level']} ({location['name']}) | \"\n            f\"XP: {xp_progress} | \"\n            f\"Fish: {player['total_fish']} | \"\n            f\"Biggest: {player['biggest_fish']:.2f} lbs\"\n        )\n\n        if player.get(\"biggest_fish_name\"):\n            stats += f\" ({player['biggest_fish_name']})\"\n\n        stats += f\" | Casts: {player['total_casts']} | Junk: {player['junk_collected']}\"\n\n        self.safe_reply(connection, event, stats)\n        return True\n\n    def _cmd_fishing_top(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        players = self.get_state(\"players\", {})\n        if not players:\n            self.safe_reply(connection, event, \"No one has gone fishing yet!\")\n            return True\n\n        # Get user map for display names\n        user_map = self.bot.get_module_state(\"users\").get(\"user_map\", {})\n\n        # Top by total fish\n        by_fish = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"total_fish\", 0) > 0],\n            key=lambda x: x[1][\"total_fish\"],\n            reverse=True\n        )[:5]\n\n        # Top by biggest fish\n        by_size = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"biggest_fish\", 0) > 0],\n            key=lambda x: x[1][\"biggest_fish\"],\n            reverse=True\n        )[:5]\n\n        response_parts = [\"Fishing Leaderboards:\"]\n\n        if by_fish:\n            fish_list = []\n            for i, (uid, p) in enumerate(by_fish):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_list.append(f\"#{i+1} {name} ({p['total_fish']})\")\n            response_parts.append(\"Most Fish: \" + \", \".join(fish_list))\n\n        if by_size:\n            size_list = []\n            for i, (uid, p) in enumerate(by_size):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_name = p.get(\"biggest_fish_name\", \"fish\")\n                size_list.append(f\"#{i+1} {name} ({p['biggest_fish']:.1f} lbs - {fish_name})\")\n            response_parts.append(\"Biggest Catch: \" + \", \".join(size_list))\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishing_location(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        current_loc = self._get_location_for_level(player[\"level\"])\n\n        # Check for active cast\n        active_casts = self.get_state(\"active_casts\", {})\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}: Currently fishing at {cast['location']} \"\n                f\"(line out for {hours:.1f} hours). Level {player['level']}.\"\n            )\n            return True\n\n        # Build location progress\n        unlocked = [l for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        next_loc = next((l for l in LOCATIONS if l[\"level\"] > player[\"level\"]), None)\n\n        response = (\n            f\"{self.bot.title_for(username)}: Level {player['level']}, \"\n            f\"currently at {current_loc['name']}. \"\n            f\"Unlocked: {', '.join(l['name'] for l in unlocked)}.\"\n        )\n\n        if next_loc:\n            xp_needed = self._get_xp_for_level(player[\"level\"])\n            response += f\" Next: {next_loc['name']} at level {next_loc['level']} ({player['xp']}/{xp_needed} XP).\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_aquarium(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        rare_catches = player.get(\"rare_catches\", [])\n\n        if not rare_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}'s aquarium is empty. \"\n                \"Catch some rare or legendary fish to display them here!\"\n            )\n            return True\n\n        # Group by rarity\n        legendaries = [c for c in rare_catches if c[\"rarity\"] == \"legendary\"]\n        rares = [c for c in rare_catches if c[\"rarity\"] == \"rare\"]\n\n        response_parts = [f\"{self.bot.title_for(username)}'s Aquarium:\"]\n\n        if legendaries:\n            leg_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in legendaries[-5:]  # Last 5\n            )\n            response_parts.append(f\"LEGENDARY: {leg_display}\")\n\n        if rares:\n            rare_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in rares[-5:]  # Last 5\n            )\n            response_parts.append(f\"Rare: {rare_display}\")\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishinfo(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        \n        # Get location argument\n        location_arg = match.group(1)\n        \n        if not location_arg:\n            # No location specified - show available locations\n            locations_fished = player.get(\"locations_fished\", [])\n            if not locations_fished:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't caught any fish yet! \"\n                    \"Use !cast and !reel to start fishing.\"\n                )\n                return True\n            \n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, locations you've fished: {', '.join(locations_fished)}. \"\n                \"Use !fishinfo <location> to see fish caught there.\"\n            )\n            return True\n        \n        # Find the location\n        location = self._find_location_by_name(location_arg)\n        if not location:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, location '{location_arg}' not found.\"\n            )\n            return True\n        \n        location_name = location[\"name\"]\n        \n        # Get catches for this location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        location_catches = catches_by_location.get(location_name, {})\n        \n        if not location_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you haven't caught any fish at {location_name} yet!\"\n            )\n            return True\n        \n        # Get all fish available at this location for completion stats\n        all_fish = FISH_DATABASE.get(location_name, [])\n        total_species = len(all_fish)\n        caught_species = len(location_catches)\n        \n        # Group by rarity\n        caught_by_rarity = {\"common\": [], \"uncommon\": [], \"rare\": [], \"legendary\": []}\n        for fish_name, count in location_catches.items():\n            # Find the fish in the database to get its rarity\n            fish_data = next((f for f in all_fish if f[\"name\"] == fish_name), None)\n            if fish_data:\n                rarity = fish_data[\"rarity\"]\n                caught_by_rarity[rarity].append(f\"{fish_name} ({count})\")\n        \n        # Build response\n        total_caught = sum(location_catches.values())\n        response_parts = [\n            f\"{self.bot.title_for(username)}'s {location_name} catches: \"\n            f\"{total_caught} fish, {caught_species}/{total_species} species\"\n        ]\n        \n        # Add fish by rarity\n        for rarity in [\"legendary\", \"rare\", \"uncommon\", \"common\"]:\n            if caught_by_rarity[rarity]:\n                rarity_label = rarity.upper() if rarity in [\"legendary\", \"rare\"] else rarity.capitalize()\n                fish_list = \", \".join(caught_by_rarity[rarity])\n                response_parts.append(f\"{rarity_label}: {fish_list}\")\n        \n        # Send as multiple messages if too long\n        full_response = \" | \".join(response_parts)\n        if len(full_response) > 400:\n            # Send in parts\n            self.safe_reply(connection, event, response_parts[0])\n            for part in response_parts[1:]:\n                self.safe_say(part, target=event.target)\n        else:\n            self.safe_reply(connection, event, full_response)\n        \n        return True\n\n    def _cmd_fishing_help(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        help_lines = [\n            \"Fishing Commands:\",\n            \"!cast - Cast at your current level (can catch fish from any unlocked lower levels)\",\n            \"!cast <location> - Cast at a specific unlocked location (e.g., !cast pond)\",\n            \"!reel - Reel in your catch (wait 1-24 hours for best results)\",\n            \"!fishing - Show your stats\",\n            \"!fishing top - Leaderboards\",\n            \"!fishing location - Current location and level progress\",\n            \"!fishinfo - List locations you've fished\",\n            \"!fishinfo <location> - Show fish caught at a specific location (e.g., !fishinfo pond)\",\n            \"!aquarium - View your rare/legendary catches\",\n            \"!water - Celebrate finishing a water bottle (boosts rare fish, max 4/day)\",\n            \"\",\n            \"Tips: !cast pulls fish from your current level and any lower unlocked levels.\",\n            \"You can also travel back to previous locations to hunt for rare fish you missed!\",\n            \"Stay hydrated! Each bottle of water increases rare fish chances by 10% (up to 40%).\",\n        ]\n\n        for line in help_lines:\n            self.safe_privmsg(username, line)\n\n        self.safe_reply(\n            connection, event,\n            f\"{self.bot.title_for(username)}, I've sent you the fishing guide.\"\n        )\n        return True\n\n    def _cmd_water(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n\n        # Get today's date\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        water_count = player.get(\"water_today\", 0)\n\n        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check if they've already had 4 bottles today\n        if water_count >= 4:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you have already consumed your four bottles of water today! \"\n                \"Most commendable dedication to hydration. Do return tomorrow for further encouragement.\"\n            )\n            return True\n\n        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)\n\n        # Calculate new boost percentage\n        boost_percentage = water_count * 10\n\n        # Build response based on how many they've had\n        if water_count == 1:\n            response = (\n                f\"Splendid! {self.bot.title_for(username)}, I am delighted to see you tending to your hydration. \"\n                f\"Three more bottles to go! Your commitment to wellness grants you a {boost_percentage}% boost \"\n                \"to catching rare and legendary fish today.\"\n            )\n        elif water_count == 2:\n            response = (\n                f\"Excellent progress, {self.bot.title_for(username)}! Two bottles down, two more to go! \"\n                f\"Your dedication is most admirable. You now have a {boost_percentage}% boost to rare catches.\"\n            )\n        elif water_count == 3:\n            response = (\n                f\"Marvelous! {self.bot.title_for(username)}, just one more bottle remains! \"\n                f\"You are nearly at peak hydration. Current boost: {boost_percentage}% to rare and legendary fish.\"\n            )\n        else:  # water_count == 4\n            response = (\n                f\"Outstanding! {self.bot.title_for(username)}, you have completed your daily hydration goal! \"\n                f\"I am exceedingly proud of your commitment to health. You now enjoy a magnificent {boost_percentage}% \"\n                \"boost to catching rare and legendary fish for the remainder of the day!\"\n            )\n\n        self.safe_reply(connection, event, response)\n        return True\n","structuredPatch":[{"oldStart":1312,"oldLines":6,"newStart":1312,"newLines":39,"lines":["             water_count = 0","             water_date = today"," ","+        # Check cooldown - must wait at least 1 hour between waters","+        water_last_used = player.get(\"water_last_used\")","+        if water_last_used and water_count > 0:","+            last_used_time = datetime.fromisoformat(water_last_used)","+            elapsed = datetime.now(UTC) - last_used_time","+            remaining_minutes = 60 - (elapsed.total_seconds() / 60)","+            if remaining_minutes > 0:","+                too_fast_messages = [","+                    (","+                        f\"I beg your pardon, {self.bot.title_for(username)}, but I find it rather difficult to believe \"","+                        f\"that you have consumed an entire bottle of water in {elapsed.total_seconds() / 60:.0f} minutes. \"","+                        f\"One does not wish to make accusations, but this has all the hallmarks of what I believe \"","+                        f\"the younger generation refers to as 'gaming the system.' Perhaps try again in {remaining_minutes:.0f} minutes.\"","+                    ),","+                    (","+                        f\"Most irregular, {self.bot.title_for(username)}. I have served in some of the finest households \"","+                        f\"in England, and I have never once witnessed a bottle of water dispatched with such supernatural haste. \"","+                        f\"Might I suggest actually drinking one? You may retry in {remaining_minutes:.0f} minutes.\"","+                    ),","+                    (","+                        f\"Forgive me, {self.bot.title_for(username)}, but unless you have developed gills — \"","+                        f\"which, while fascinating, seems improbable — I rather suspect this water bottle is purely theoretical. \"","+                        f\"The next hydration opportunity presents itself in {remaining_minutes:.0f} minutes.\"","+                    ),","+                    (","+                        f\"I venture to observe, {self.bot.title_for(username)}, that the speed of your alleged consumption \"","+                        f\"would make even the most enthusiastic camel raise an eyebrow. One hesitates to use the word \"","+                        f\"'shenanigans,' but the evidence is compelling. Do try again in {remaining_minutes:.0f} minutes.\"","+                    ),","+                ]","+                self.safe_reply(connection, event, random.choice(too_fast_messages))","+                return True","+","         # Check if they've already had 4 bottles today","         if water_count >= 4:","             self.safe_reply("]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"600a7038-ac6c-4852-a23a-8370e8d9fa6e"}
{"parentUuid":"91913b37-fca1-4917-8dfb-5aa0c9a7bc9a","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01GcoeejVyLYmX4oSexRgW37","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to save the timestamp when a water is successfully consumed. Let me update the part where the counter is incremented:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1110,"cache_read_input_tokens":43039,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1110},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HpRSvyBFLVFMTSnqo4","type":"assistant","uuid":"f2c40d7d-b446-46c6-b1b9-4439aef295e1","timestamp":"2026-02-12T01:15:58.385Z"}
{"parentUuid":"f2c40d7d-b446-46c6-b1b9-4439aef295e1","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01GcoeejVyLYmX4oSexRgW37","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K4GhVAwLEsNLJEut6mPjNR","name":"Edit","input":{"replace_all":false,"file_path":"/home/nylan/code/jeeves/modules/fishing.py","old_string":"        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)","new_string":"        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        player[\"water_last_used\"] = datetime.now(UTC).isoformat()\n        self._save_player(user_id, player)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1110,"cache_read_input_tokens":43039,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1110},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3HpRSvyBFLVFMTSnqo4","type":"assistant","uuid":"b83cfbf7-fa64-4485-84fa-f63540c3825b","timestamp":"2026-02-12T01:16:00.795Z"}
{"parentUuid":"b83cfbf7-fa64-4485-84fa-f63540c3825b","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01K4GhVAwLEsNLJEut6mPjNR","toolUseID":"toolu_01K4GhVAwLEsNLJEut6mPjNR","timestamp":"2026-02-12T01:16:05.489Z","uuid":"60e2cc23-6cdf-4cc3-90f1-594f65b23818"}
{"parentUuid":"b83cfbf7-fa64-4485-84fa-f63540c3825b","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K4GhVAwLEsNLJEut6mPjNR","type":"tool_result","content":"The file /home/nylan/code/jeeves/modules/fishing.py has been updated successfully."}]},"uuid":"4b9c1c5d-ffec-4309-abc5-bc67d0abc3f2","timestamp":"2026-02-12T01:16:05.489Z","toolUseResult":{"filePath":"/home/nylan/code/jeeves/modules/fishing.py","oldString":"        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)","newString":"        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        player[\"water_last_used\"] = datetime.now(UTC).isoformat()\n        self._save_player(user_id, player)","originalFile":"# modules/fishing.py\n# A fishing mini-game where users cast lines and reel in catches over time.\n\nimport random\nimport re\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom .base import SimpleCommandModule\nfrom . import achievement_hooks\n\nUTC = timezone.utc\n\n\ndef setup(bot: Any) -> 'Fishing':\n    return Fishing(bot)\n\n\n# Fishing locations unlocked by level (0-9)\nLOCATIONS = [\n    {\"name\": \"Puddle\", \"level\": 0, \"max_distance\": 5, \"type\": \"terrestrial\"},\n    {\"name\": \"Pond\", \"level\": 1, \"max_distance\": 15, \"type\": \"terrestrial\"},\n    {\"name\": \"Lake\", \"level\": 2, \"max_distance\": 30, \"type\": \"terrestrial\"},\n    {\"name\": \"River\", \"level\": 3, \"max_distance\": 50, \"type\": \"terrestrial\"},\n    {\"name\": \"Ocean\", \"level\": 4, \"max_distance\": 100, \"type\": \"terrestrial\"},\n    {\"name\": \"Deep Sea\", \"level\": 5, \"max_distance\": 200, \"type\": \"terrestrial\"},\n    {\"name\": \"Moon\", \"level\": 6, \"max_distance\": 500, \"type\": \"space\"},\n    {\"name\": \"Mars\", \"level\": 7, \"max_distance\": 1000, \"type\": \"space\"},\n    {\"name\": \"Jupiter\", \"level\": 8, \"max_distance\": 2000, \"type\": \"space\"},\n    {\"name\": \"The Void\", \"level\": 9, \"max_distance\": 5000, \"type\": \"space\"},\n]\n\n# Fish database organized by location\n# Each fish has: name, min_weight, max_weight, rarity\nFISH_DATABASE: Dict[str, List[Dict[str, Any]]] = {\n    \"Puddle\": [\n        # Common\n        {\"name\": \"Minnow\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        {\"name\": \"Tadpole\", \"min_weight\": 0.05, \"max_weight\": 0.2, \"rarity\": \"common\"},\n        {\"name\": \"Guppy\", \"min_weight\": 0.1, \"max_weight\": 0.3, \"rarity\": \"common\"},\n        {\"name\": \"Water Beetle\", \"min_weight\": 0.01, \"max_weight\": 0.1, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Goldfish\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Small Frog\", \"min_weight\": 0.3, \"max_weight\": 1.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Koi\", \"min_weight\": 2.0, \"max_weight\": 5.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Puddle King\", \"min_weight\": 8.0, \"max_weight\": 15.0, \"rarity\": \"legendary\"},\n    ],\n    \"Pond\": [\n        # Common\n        {\"name\": \"Bluegill\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Perch\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Sunfish\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Crayfish\", \"min_weight\": 0.1, \"max_weight\": 0.5, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Largemouth Bass\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Catfish\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Perch\", \"min_weight\": 5.0, \"max_weight\": 12.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Old Whiskers\", \"min_weight\": 20.0, \"max_weight\": 40.0, \"rarity\": \"legendary\"},\n    ],\n    \"Lake\": [\n        # Common\n        {\"name\": \"Trout\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Crappie\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Walleye\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Pike\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Lake Sturgeon\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Muskie\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Albino Sturgeon\", \"min_weight\": 20.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Nessie's Cousin\", \"min_weight\": 100.0, \"max_weight\": 200.0, \"rarity\": \"legendary\"},\n    ],\n    \"River\": [\n        # Common\n        {\"name\": \"Salmon\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Steelhead\", \"min_weight\": 4.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        {\"name\": \"River Carp\", \"min_weight\": 3.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Smallmouth Bass\", \"min_weight\": 2.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"King Salmon\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Paddlefish\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Golden Salmon\", \"min_weight\": 25.0, \"max_weight\": 50.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The River Guardian\", \"min_weight\": 80.0, \"max_weight\": 150.0, \"rarity\": \"legendary\"},\n    ],\n    \"Ocean\": [\n        # Common\n        {\"name\": \"Tuna\", \"min_weight\": 20.0, \"max_weight\": 80.0, \"rarity\": \"common\"},\n        {\"name\": \"Mackerel\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Sea Bass\", \"min_weight\": 10.0, \"max_weight\": 40.0, \"rarity\": \"common\"},\n        {\"name\": \"Flounder\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Swordfish\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Mahi-Mahi\", \"min_weight\": 15.0, \"max_weight\": 50.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Barracuda\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Blue Marlin\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Sailfish\", \"min_weight\": 80.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"Moby Dick Jr.\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Deep Sea\": [\n        # Common\n        {\"name\": \"Anglerfish\", \"min_weight\": 5.0, \"max_weight\": 20.0, \"rarity\": \"common\"},\n        {\"name\": \"Viperfish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Gulper Eel\", \"min_weight\": 3.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Lanternfish\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Giant Squid\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Oarfish\", \"min_weight\": 30.0, \"max_weight\": 100.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Goblin Shark\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Colossal Squid\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Megamouth Shark\", \"min_weight\": 300.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Kraken\", \"min_weight\": 1000.0, \"max_weight\": 2500.0, \"rarity\": \"legendary\"},\n    ],\n    \"Moon\": [\n        # Common\n        {\"name\": \"Moon Jellyfish\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Lunar Shrimp\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Crater Minnow\", \"min_weight\": 0.3, \"max_weight\": 1.5, \"rarity\": \"common\"},\n        {\"name\": \"Dust Swimmer\", \"min_weight\": 1.0, \"max_weight\": 4.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Crater Crab\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Void Eel\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Selenite Fish\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Cosmic Whale\", \"min_weight\": 50.0, \"max_weight\": 200.0, \"rarity\": \"rare\"},\n        {\"name\": \"Starlight Serpent\", \"min_weight\": 40.0, \"max_weight\": 150.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Leviathan of Tranquility\", \"min_weight\": 500.0, \"max_weight\": 1000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Mars\": [\n        # Common\n        {\"name\": \"Rust Minnow\", \"min_weight\": 0.5, \"max_weight\": 2.0, \"rarity\": \"common\"},\n        {\"name\": \"Red Silt Crawler\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Iron Guppy\", \"min_weight\": 0.5, \"max_weight\": 3.0, \"rarity\": \"common\"},\n        {\"name\": \"Dust Devil Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Olympus Bass\", \"min_weight\": 10.0, \"max_weight\": 30.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Valles Trout\", \"min_weight\": 15.0, \"max_weight\": 40.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Phobos Flounder\", \"min_weight\": 8.0, \"max_weight\": 25.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Martian Kraken\", \"min_weight\": 100.0, \"max_weight\": 300.0, \"rarity\": \"rare\"},\n        {\"name\": \"Red Planet Leviathan\", \"min_weight\": 150.0, \"max_weight\": 400.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Ancient One\", \"min_weight\": 1000.0, \"max_weight\": 2000.0, \"rarity\": \"legendary\"},\n    ],\n    \"Jupiter\": [\n        # Common\n        {\"name\": \"Gas Giant Jellyfish\", \"min_weight\": 2.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Storm Swimmer\", \"min_weight\": 5.0, \"max_weight\": 15.0, \"rarity\": \"common\"},\n        {\"name\": \"Ammonia Minnow\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Cloud Drifter\", \"min_weight\": 3.0, \"max_weight\": 12.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Red Spot Ray\", \"min_weight\": 20.0, \"max_weight\": 60.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Ammonia Eel\", \"min_weight\": 30.0, \"max_weight\": 80.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Io Salmon\", \"min_weight\": 25.0, \"max_weight\": 70.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Jovian Leviathan\", \"min_weight\": 200.0, \"max_weight\": 500.0, \"rarity\": \"rare\"},\n        {\"name\": \"Europa Ice Beast\", \"min_weight\": 250.0, \"max_weight\": 600.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Great Red Serpent\", \"min_weight\": 2000.0, \"max_weight\": 4000.0, \"rarity\": \"legendary\"},\n    ],\n    \"The Void\": [\n        # Common\n        {\"name\": \"Void Mite\", \"min_weight\": 1.0, \"max_weight\": 5.0, \"rarity\": \"common\"},\n        {\"name\": \"Dark Matter Shrimp\", \"min_weight\": 3.0, \"max_weight\": 10.0, \"rarity\": \"common\"},\n        {\"name\": \"Null Fish\", \"min_weight\": 2.0, \"max_weight\": 8.0, \"rarity\": \"common\"},\n        {\"name\": \"Entropy Minnow\", \"min_weight\": 1.0, \"max_weight\": 6.0, \"rarity\": \"common\"},\n        # Uncommon\n        {\"name\": \"Entropy Eel\", \"min_weight\": 25.0, \"max_weight\": 75.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Singularity Squid\", \"min_weight\": 50.0, \"max_weight\": 150.0, \"rarity\": \"uncommon\"},\n        {\"name\": \"Dimensional Drifter\", \"min_weight\": 40.0, \"max_weight\": 120.0, \"rarity\": \"uncommon\"},\n        # Rare\n        {\"name\": \"Reality Warper\", \"min_weight\": 300.0, \"max_weight\": 800.0, \"rarity\": \"rare\"},\n        {\"name\": \"Event Horizon Eel\", \"min_weight\": 400.0, \"max_weight\": 900.0, \"rarity\": \"rare\"},\n        # Legendary\n        {\"name\": \"The Cosmic Horror\", \"min_weight\": 5000.0, \"max_weight\": 10000.0, \"rarity\": \"legendary\"},\n        {\"name\": \"Cthulhu's Cousin\", \"min_weight\": 8000.0, \"max_weight\": 15000.0, \"rarity\": \"legendary\"},\n    ],\n}\n\n# Junk items by location type\nJUNK_ITEMS: Dict[str, List[str]] = {\n    \"terrestrial\": [\n        \"Old Boot\", \"Rusty Tin Can\", \"Soggy Newspaper\", \"Tangled Fishing Line\",\n        \"Broken Sunglasses\", \"Waterlogged Book\", \"Deflated Beach Ball\", \"Lost Flip-Flop\",\n        \"Shopping Cart Wheel\", \"Plastic Bottle\", \"Tire\", \"Underwear\", \"License Plate\",\n        \"Broken Umbrella\", \"Moldy Wallet\", \"Damp Cigarette Pack\", \"Fishing Bobber\",\n        \"Knitting Needle\", \"Crochet Hook\", \"Tangled Yarn Ball\", \"Stitch Marker\",\n        \"Frayed Crochet Bag\", \"Half-Finished Scarf\", \"Pattern Printout\",\n        \"Game Controller\", \"Pixelated Cartridge\", \"Arcade Token\", \"Headset Mic\",\n        \"Trophy Cup\", \"Resistance Band\", \"Kettlebell\", \"Gym Towel\",\n        \"Protein Shaker\", \"Yoga Mat\", \"Jump Rope\",\n    ],\n    \"space\": [\n        \"Space Debris\", \"Frozen Oxygen Chunk\", \"Abandoned Satellite\", \"Lost Astronaut Glove\",\n        \"Alien Artifact\", \"Meteor Fragment\", \"Cosmic Dust Bunny\", \"Derelict Probe\",\n        \"Ancient Star Map\", \"Fossilized Moonrock\", \"Mysterious Orb\", \"Quantum Fluctuation\",\n        \"Void Crystal\", \"Broken Warp Core\", \"Lost Space Buoy\", \"Crystallized Stardust\",\n        \"Zero-G Yarn Ball\", \"Starlight Crochet Hook\", \"Orbital Knitting Needle\",\n        \"Cosmic Game Controller\", \"Nebula Cartridge\", \"Warped Arcade Token\",\n        \"Anti-Gravity Kettlebell\", \"Meteorite Dumbbell\", \"Vacuum-Sealed Gym Towel\",\n        \"Protein Paste Packet\", \"Quantum Jump Rope\",\n    ],\n}\n\n# Random events that can trigger\nEVENTS: Dict[str, Dict[str, Any]] = {\n    \"full_moon\": {\n        \"name\": \"Full Moon\",\n        \"description\": \"The full moon rises! Rare fish are more active.\",\n        \"effect\": \"rare_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 30,\n    },\n    \"solar_flare\": {\n        \"name\": \"Solar Flare\",\n        \"description\": \"A solar flare energizes the waters! Double XP!\",\n        \"effect\": \"xp_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n    \"feeding_frenzy\": {\n        \"name\": \"Feeding Frenzy\",\n        \"description\": \"The fish are hungry! Catches are easier.\",\n        \"effect\": \"time_boost\",\n        \"multiplier\": 0.5,  # Halves effective required time\n        \"duration_minutes\": 25,\n    },\n    \"murky_waters\": {\n        \"name\": \"Murky Waters\",\n        \"description\": \"The waters are murky... more junk than usual.\",\n        \"effect\": \"junk_boost\",\n        \"multiplier\": 2.0,\n        \"duration_minutes\": 15,\n    },\n    \"meteor_shower\": {\n        \"name\": \"Meteor Shower\",\n        \"description\": \"A meteor shower brings strange creatures from beyond!\",\n        \"effect\": \"alien_fish\",\n        \"duration_minutes\": 20,\n        \"locations\": [\"Moon\", \"Mars\", \"Jupiter\", \"The Void\"],\n    },\n}\n\n# Rarity weights for fish selection\nRARITY_WEIGHTS = {\n    \"common\": 70,\n    \"uncommon\": 20,\n    \"rare\": 8,\n    \"legendary\": 2,\n}\n\n# XP multipliers by rarity\nRARITY_XP_MULTIPLIER = {\n    \"common\": 1,\n    \"uncommon\": 2,\n    \"rare\": 5,\n    \"legendary\": 20,\n}\n\n# XP bonus chances (per successful catch)\nXP_BONUS_SMALL_CHANCE = 0.04\nXP_BONUS_LARGE_CHANCE = 0.01\nXP_BOOST_ROD_CHANCE = 0.007\nXP_BOOST_ROD_CATCHES = 5\nXP_BOOST_MULTIPLIER = 2\nXP_BONUS_SMALL_RANGE = (8, 20)\nXP_BONUS_LARGE_RANGE = (40, 90)\n\n# Cast flavor messages\nCAST_MESSAGES = [\n    \"You cast your line, it goes {distance}m and floats quietly...\",\n    \"With a practiced flick, your line sails {distance}m into the {location}.\",\n    \"Your line arcs gracefully, landing {distance}m away in the {location}.\",\n    \"The line whips through the air, settling {distance}m out.\",\n    \"You send your line sailing {distance}m. Now we wait...\",\n]\n\n# Reel too early messages\nTOO_EARLY_MESSAGES = [\n    \"You reel in too soon - the line is empty. Perhaps patience is a virtue?\",\n    \"Nothing but an empty hook. The fish need more time to find your bait.\",\n    \"Your line comes back bare. Try waiting a bit longer next time.\",\n    \"Too hasty! The fish haven't even noticed your bait yet.\",\n    \"An empty catch. Good things come to those who wait.\",\n]\n\n# Danger zone messages (over 24 hours)\nDANGER_ZONE_MESSAGES = {\n    \"line_break\": [\n        \"The line finally snaps from the strain! It was out there too long.\",\n        \"Your line, weakened by time, breaks as you try to reel in.\",\n        \"The elements have taken their toll - your line breaks clean off!\",\n    ],\n    \"fish_escaped\": [\n        \"The fish got tired of waiting and swam away ages ago.\",\n        \"Whatever was on the line has long since escaped.\",\n        \"You reel in... nothing. The fish left hours ago.\",\n    ],\n    \"junk\": [\n        \"After all that time, you only catch some waterlogged junk.\",\n        \"The long wait rewards you with... garbage. How fitting.\",\n    ],\n}\n\n\nclass Fishing(SimpleCommandModule):\n    name = \"fishing\"\n    version = \"1.0.0\"\n    description = \"A fishing mini-game with locations, leveling, and rare catches.\"\n\n    # Time thresholds in hours\n    MIN_WAIT_HOURS = 1.0\n    OPTIMAL_WAIT_HOURS = 24.0\n    DANGER_THRESHOLD_HOURS = 24.0\n    MAX_DANGER_HOURS = 48.0\n\n    def __init__(self, bot: Any) -> None:\n        super().__init__(bot)\n\n        # Initialize state\n        if not self.get_state(\"active_casts\"):\n            self.set_state(\"active_casts\", {})\n        if not self.get_state(\"players\"):\n            self.set_state(\"players\", {})\n        if not self.get_state(\"active_event\"):\n            self.set_state(\"active_event\", None)\n        self.save_state()\n\n    def _register_commands(self) -> None:\n        self.register_command(\n            r'^\\s*!cast(?:\\s+(.+))?\\s*$',\n            self._cmd_cast,\n            name=\"cast\",\n            description=\"Cast your fishing line (optionally specify location)\"\n        )\n        self.register_command(\n            r'^\\s*!reel\\s*$',\n            self._cmd_reel,\n            name=\"reel\",\n            description=\"Reel in your catch\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing|stats)?\\s*$',\n            self._cmd_fishing_stats,\n            name=\"fishing\",\n            description=\"Show your fishing statistics\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+top\\s*$',\n            self._cmd_fishing_top,\n            name=\"fishing top\",\n            description=\"Show fishing leaderboards\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+location\\s*$',\n            self._cmd_fishing_location,\n            name=\"fishing location\",\n            description=\"Show your current fishing location\"\n        )\n        self.register_command(\n            r'^\\s*!fishinfo(?:\\s+(.+))?\\s*$',\n            self._cmd_fishinfo,\n            name=\"fishinfo\",\n            description=\"Show fish caught in a specific location\"\n        )\n        self.register_command(\n            r'^\\s*!aquarium\\s*$',\n            self._cmd_aquarium,\n            name=\"aquarium\",\n            description=\"Show your rare and legendary catches\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+help\\s*$',\n            self._cmd_fishing_help,\n            name=\"fishing help\",\n            description=\"Show fishing help\"\n        )\n        self.register_command(\n            r'^\\s*!fish(?:ing)?\\s+bless\\s+(\\S+)\\s*$',\n            self._cmd_fishing_bless,\n            name=\"fishing bless\",\n            admin_only=True,\n            description=\"[Admin] Guarantee a user's next catch is rare or legendary\"\n        )\n        self.register_command(\n            r'^\\s*!water\\s*$',\n            self._cmd_water,\n            name=\"water\",\n            description=\"Celebrate finishing a water bottle (boosts rare fish chances)\"\n        )\n\n    def _get_player(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Get or create a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        if user_id not in players:\n            players[user_id] = {\n                \"level\": 0,\n                \"xp\": 0,\n                \"total_fish\": 0,\n                \"biggest_fish\": 0.0,\n                \"biggest_fish_name\": None,\n                \"total_casts\": 0,\n                \"furthest_cast\": 0.0,\n                \"lines_broken\": 0,\n                \"junk_collected\": 0,\n                \"catches\": {},\n                \"catches_by_location\": {},  # {\"location_name\": {\"fish_name\": count}}\n                \"rare_catches\": [],\n                \"locations_fished\": [],\n                \"water_today\": 0,  # Number of water bottles consumed today\n                \"water_date\": None,  # Date of last water consumption (for daily reset)\n                \"water_last_used\": None,  # ISO timestamp of last !water command\n                \"xp_boost_catches\": 0,\n                \"force_rare_legendary\": False,\n            }\n            self.set_state(\"players\", players)\n            self.save_state()\n        return players[user_id]\n\n    def _save_player(self, user_id: str, player: Dict[str, Any]) -> None:\n        \"\"\"Save a player record.\"\"\"\n        players = self.get_state(\"players\", {})\n        players[user_id] = player\n        self.set_state(\"players\", players)\n        self.save_state()\n\n    def _get_location_for_level(self, level: int) -> Dict[str, Any]:\n        \"\"\"Get the location a player can fish at based on their level.\"\"\"\n        # Player fishes at their max unlocked location\n        for loc in reversed(LOCATIONS):\n            if loc[\"level\"] <= level:\n                return loc\n        return LOCATIONS[0]\n\n    def _find_location_by_name(self, location_query: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Find a location by name (case-insensitive, supports partial matches).\"\"\"\n        query = location_query.strip().lower()\n        \n        # Try exact match first\n        for loc in LOCATIONS:\n            if loc[\"name\"].lower() == query:\n                return loc\n        \n        # Try partial match\n        for loc in LOCATIONS:\n            if query in loc[\"name\"].lower():\n                return loc\n        \n        return None\n\n    def _get_xp_for_level(self, level: int) -> int:\n        \"\"\"Calculate XP needed for a level.\"\"\"\n        return int(100 * ((level + 1) ** 1.5))\n\n    def _check_level_up(self, user_id: str, player: Dict[str, Any], username: str) -> Optional[int]:\n        \"\"\"Check if player leveled up, return new level if so.\"\"\"\n        current_level = player[\"level\"]\n        xp = player[\"xp\"]\n\n        while current_level < 9:  # Max level is 9\n            xp_needed = self._get_xp_for_level(current_level)\n            if xp >= xp_needed:\n                xp -= xp_needed\n                current_level += 1\n            else:\n                break\n\n        if current_level > player[\"level\"]:\n            player[\"level\"] = current_level\n            player[\"xp\"] = xp\n            self._save_player(user_id, player)\n            # Record achievement progress\n            achievement_hooks.record_fishing_level(self.bot, username, current_level)\n            return current_level\n\n        player[\"xp\"] = xp\n        return None\n\n    def _get_cast_distance(self, level: int, location: Dict[str, Any]) -> float:\n        \"\"\"Generate a random cast distance based on level and location.\"\"\"\n        max_dist = location[\"max_distance\"]\n        # Base distance is 30-70% of max, with level adding potential\n        min_dist = max_dist * 0.3\n        level_bonus = (level / 9) * 0.3  # Up to 30% bonus at max level\n        base_max = max_dist * (0.7 + level_bonus)\n        return round(random.uniform(min_dist, base_max), 1)\n\n    def _select_rarity(self, wait_hours: float, event: Optional[Dict[str, Any]] = None, water_boost: float = 0.0) -> str:\n        \"\"\"Select a rarity tier based on wait time, active events, and hydration boost.\"\"\"\n        weights = RARITY_WEIGHTS.copy()\n\n        # Adjust weights based on wait time\n        # < 6 hours: only common really\n        # 6-12: uncommon possible\n        # 12-18: rare possible\n        # 18-24: legendary possible\n\n        if wait_hours < 6:\n            weights[\"uncommon\"] = 5\n            weights[\"rare\"] = 0\n            weights[\"legendary\"] = 0\n        elif wait_hours < 12:\n            weights[\"rare\"] = 2\n            weights[\"legendary\"] = 0\n        elif wait_hours < 18:\n            weights[\"legendary\"] = 0\n        # else: full weights at 18+ hours\n\n        # Apply event bonuses\n        if event and event.get(\"effect\") == \"rare_boost\":\n            weights[\"rare\"] = int(weights[\"rare\"] * event.get(\"multiplier\", 1))\n            weights[\"legendary\"] = int(weights[\"legendary\"] * event.get(\"multiplier\", 1))\n\n        # Apply water boost (increases rare and legendary chances)\n        if water_boost > 0:\n            # Reduce common weight by the boost percentage\n            common_reduction = weights[\"common\"] * water_boost\n            weights[\"common\"] = max(1, int(weights[\"common\"] - common_reduction))\n            \n            # Distribute the reduction to rare and legendary\n            weights[\"rare\"] = int(weights[\"rare\"] + common_reduction * 0.6)\n            weights[\"legendary\"] = int(weights[\"legendary\"] + common_reduction * 0.4)\n\n        # Weighted random selection\n        total = sum(weights.values())\n        roll = random.randint(1, total)\n        cumulative = 0\n        for rarity, weight in weights.items():\n            cumulative += weight\n            if roll <= cumulative:\n                return rarity\n        return \"common\"\n\n    def _select_fish(\n        self,\n        location: str,\n        rarity: str,\n        eligible_locations: Optional[List[str]] = None,\n        allow_fallback: bool = True,\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"Select a fish from the eligible location pools matching the rarity.\"\"\"\n        if eligible_locations:\n            fish_pool = []\n            for loc_name in eligible_locations:\n                fish_pool.extend(FISH_DATABASE.get(loc_name, []))\n        else:\n            fish_pool = FISH_DATABASE.get(location, [])\n        matching = [f for f in fish_pool if f[\"rarity\"] == rarity]\n        if not matching and allow_fallback:\n            # Fall back to common if no fish of that rarity\n            matching = [f for f in fish_pool if f[\"rarity\"] == \"common\"]\n        if not matching:\n            return None\n        return random.choice(matching)\n\n    def _calculate_weight(self, fish: Dict[str, Any], wait_hours: float) -> float:\n        \"\"\"Calculate actual fish weight based on wait time.\"\"\"\n        min_w = fish[\"min_weight\"]\n        max_w = fish[\"max_weight\"]\n\n        # Weight scales with wait time up to 24 hours\n        time_factor = min(wait_hours / self.OPTIMAL_WAIT_HOURS, 1.0)\n\n        # Random variance within the range, biased by time factor\n        base_weight = min_w + (max_w - min_w) * time_factor\n        variance = (max_w - min_w) * 0.2  # 20% variance\n        weight = base_weight + random.uniform(-variance, variance)\n\n        return round(max(min_w, min(max_w, weight)), 2)\n\n    def _get_junk(self, location_type: str) -> str:\n        \"\"\"Get a random junk item.\"\"\"\n        items = JUNK_ITEMS.get(location_type, JUNK_ITEMS[\"terrestrial\"])\n        return random.choice(items)\n\n    def _check_event_trigger(self, channel: str, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"5% chance to trigger a random event on cast.\"\"\"\n        if random.random() > 0.05:\n            return None\n\n        # Select a random event\n        available_events = []\n        for event_id, event in EVENTS.items():\n            # Check if event is location-restricted\n            if \"locations\" in event and location not in event[\"locations\"]:\n                continue\n            available_events.append((event_id, event))\n\n        if not available_events:\n            return None\n\n        event_id, event = random.choice(available_events)\n        expires = datetime.now(UTC) + timedelta(minutes=event[\"duration_minutes\"])\n\n        active_event = {\n            \"type\": event_id,\n            \"name\": event[\"name\"],\n            \"description\": event[\"description\"],\n            \"effect\": event.get(\"effect\"),\n            \"multiplier\": event.get(\"multiplier\", 1.0),\n            \"expires\": expires.isoformat(),\n            \"announced_channels\": [channel],\n        }\n\n        self.set_state(\"active_event\", active_event)\n        self.save_state()\n\n        return active_event\n\n    def _get_active_event(self, location: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get the currently active event if any and valid for location.\"\"\"\n        event = self.get_state(\"active_event\")\n        if not event:\n            return None\n\n        # Check if expired\n        expires = datetime.fromisoformat(event[\"expires\"])\n        if datetime.now(UTC) >= expires:\n            self.set_state(\"active_event\", None)\n            self.save_state()\n            return None\n\n        # Check location restriction\n        event_data = EVENTS.get(event[\"type\"], {})\n        if \"locations\" in event_data and location not in event_data[\"locations\"]:\n            return None\n\n        return event\n\n    def _get_water_boost(self, player: Dict[str, Any]) -> float:\n        \"\"\"Get the current water boost percentage (0.0 to 0.4 for 0% to 40%).\"\"\"\n        # Check if we need to reset daily counter\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        \n        if water_date != today:\n            # New day, reset counter\n            return 0.0\n        \n        # Each water bottle adds 10% boost, max 4 bottles = 40%\n        water_count = player.get(\"water_today\", 0)\n        return min(water_count * 0.10, 0.40)\n\n    def _cmd_cast(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if already has active cast\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you already have a line in the water at {cast['location']}! \"\n                f\"It's been {hours:.1f} hours. Use !reel to bring it in.\"\n            )\n            return True\n\n        player = self._get_player(user_id)\n        \n        # Check if location argument was provided\n        location_arg = match.group(1)\n        if location_arg:\n            # Try to find the requested location\n            requested_location = self._find_location_by_name(location_arg)\n            \n            if not requested_location:\n                # List all available locations\n                available_locs = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, location '{location_arg}' not found. \"\n                    f\"Available locations: {', '.join(available_locs)}\"\n                )\n                return True\n            \n            # Check if player has unlocked this location\n            if requested_location[\"level\"] > player[\"level\"]:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't unlocked {requested_location['name']} yet! \"\n                    f\"You need to be level {requested_location['level']} (currently level {player['level']}).\"\n                )\n                return True\n            \n            location = requested_location\n        else:\n            # No location specified, use current level's default location\n            location = self._get_location_for_level(player[\"level\"])\n        \n        distance = self._get_cast_distance(player[\"level\"], location)\n\n        # Record the cast\n        active_casts[user_id] = {\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"distance\": distance,\n            \"location\": location[\"name\"],\n            \"channel\": event.target,\n            \"allow_lower_fish\": not location_arg,\n        }\n        self.set_state(\"active_casts\", active_casts)\n\n        # Update player stats\n        player[\"total_casts\"] += 1\n        if distance > player[\"furthest_cast\"]:\n            player[\"furthest_cast\"] = distance\n        self._save_player(user_id, player)\n\n        # Check for event trigger\n        triggered_event = self._check_event_trigger(event.target, location[\"name\"])\n\n        # Send cast message\n        cast_msg = random.choice(CAST_MESSAGES).format(\n            distance=distance,\n            location=location[\"name\"]\n        )\n        self.safe_reply(connection, event, f\"{self.bot.title_for(username)}, {cast_msg}\")\n\n        # Announce event if triggered\n        if triggered_event:\n            self.safe_say(\n                f\"** {triggered_event['name']} ** - {triggered_event['description']}\",\n                target=event.target\n            )\n\n        return True\n\n    def _cmd_reel(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        active_casts = self.get_state(\"active_casts\", {})\n\n        # Check if has active cast\n        if user_id not in active_casts:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you don't have a line in the water. Use !cast first.\"\n            )\n            return True\n\n        cast = active_casts[user_id]\n        cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n        now = datetime.now(UTC)\n        elapsed = now - cast_time\n        wait_hours = elapsed.total_seconds() / 3600\n\n        location_name = cast[\"location\"]\n        location = next((l for l in LOCATIONS if l[\"name\"] == location_name), LOCATIONS[0])\n        player = self._get_player(user_id)\n        forced_rare_flag = player.get(\"force_rare_legendary\", False)\n\n        # Remove the cast\n        del active_casts[user_id]\n        self.set_state(\"active_casts\", active_casts)\n        self.save_state()\n\n        # Get active event\n        active_event = self._get_active_event(location_name)\n\n        # Apply time boost event if active\n        effective_wait = wait_hours\n        if active_event and active_event.get(\"effect\") == \"time_boost\":\n            effective_wait = wait_hours / active_event.get(\"multiplier\", 1.0)\n\n        # Too early - nothing caught\n        if effective_wait < self.MIN_WAIT_HOURS:\n            self.safe_reply(connection, event, random.choice(TOO_EARLY_MESSAGES))\n            return True\n\n        # Danger zone - chance of bad outcome\n        if wait_hours > self.DANGER_THRESHOLD_HOURS and not forced_rare_flag:\n            hours_over = wait_hours - self.DANGER_THRESHOLD_HOURS\n            bad_chance = min(0.1 + (hours_over * 0.05), 0.9)\n\n            if random.random() < bad_chance:\n                # Bad outcome\n                bad_type = random.choice([\"line_break\", \"fish_escaped\", \"junk\"])\n\n                if bad_type == \"line_break\":\n                    player[\"lines_broken\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"line_break\"])\n                    )\n                elif bad_type == \"fish_escaped\":\n                    self.safe_reply(\n                        connection, event,\n                        random.choice(DANGER_ZONE_MESSAGES[\"fish_escaped\"])\n                    )\n                else:  # junk\n                    junk = self._get_junk(location[\"type\"])\n                    player[\"junk_collected\"] += 1\n                    self._save_player(user_id, player)\n                    achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                    self.safe_reply(\n                        connection, event,\n                        f\"After waiting {wait_hours:.1f} hours, you reel in... {junk}. \"\n                        \"Maybe don't leave your line out so long next time.\"\n                    )\n                return True\n\n        # Junk check (base chance, boosted by murky waters)\n        if not forced_rare_flag:\n            junk_chance = 0.10\n            if active_event and active_event.get(\"effect\") == \"junk_boost\":\n                junk_chance *= active_event.get(\"multiplier\", 1.0)\n\n            if random.random() < junk_chance:\n                junk = self._get_junk(location[\"type\"])\n                player[\"junk_collected\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"junk_collected\", 1)\n                xp_gain = 5  # Small XP for junk\n                player[\"xp\"] += xp_gain\n                self._save_player(user_id, player)\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)} reels in... {junk}. \"\n                    f\"Well, at least you're cleaning up! (+{xp_gain} XP)\"\n                )\n                return True\n\n        # Successful catch!\n        water_boost = self._get_water_boost(player)\n        rarity = self._select_rarity(effective_wait, active_event, water_boost)\n        eligible_locations = None\n        if cast.get(\"allow_lower_fish\"):\n            eligible_locations = [l[\"name\"] for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        fish = None\n        forced_rare = player.get(\"force_rare_legendary\", False)\n        forced_rare_applied = False\n        if forced_rare:\n            forced_rarities = [\"rare\", \"legendary\"]\n            random.shuffle(forced_rarities)\n            for forced in forced_rarities:\n                fish = self._select_fish(\n                    location_name,\n                    forced,\n                    eligible_locations,\n                    allow_fallback=False,\n                )\n                if fish:\n                    rarity = forced\n                    forced_rare_applied = True\n                    break\n\n        if not fish:\n            fish = self._select_fish(location_name, rarity, eligible_locations)\n\n        if not fish:\n            # Fallback - shouldn't happen\n            self.safe_reply(connection, event, \"The fish got away at the last moment!\")\n            return True\n\n        weight = self._calculate_weight(fish, effective_wait)\n\n        # Line break check - bigger fish = higher chance\n        if not forced_rare_applied:\n            break_chance = 0.02 + (weight / 1000) * 0.15\n            if random.random() < break_chance:\n                player[\"lines_broken\"] += 1\n                self._save_player(user_id, player)\n                achievement_hooks.record_achievement(self.bot, username, \"lines_broken\", 1)\n                self.safe_reply(\n                    connection, event,\n                    f\"You feel a massive tug - it's a {fish['name']}! But the weight is too much... \"\n                    f\"SNAP! The line breaks! It got away...\"\n                )\n                return True\n\n        # Successful catch!\n        player[\"total_fish\"] += 1\n        if weight > player[\"biggest_fish\"]:\n            player[\"biggest_fish\"] = weight\n            player[\"biggest_fish_name\"] = fish[\"name\"]\n\n        if forced_rare_applied:\n            player[\"force_rare_legendary\"] = False\n\n        # Track catches (global)\n        catches = player.get(\"catches\", {})\n        catches[fish[\"name\"]] = catches.get(fish[\"name\"], 0) + 1\n        player[\"catches\"] = catches\n\n        # Track catches by location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        if location_name not in catches_by_location:\n            catches_by_location[location_name] = {}\n        catches_by_location[location_name][fish[\"name\"]] = catches_by_location[location_name].get(fish[\"name\"], 0) + 1\n        player[\"catches_by_location\"] = catches_by_location\n\n        # Track location\n        if location_name not in player.get(\"locations_fished\", []):\n            player.setdefault(\"locations_fished\", []).append(location_name)\n\n        # Track rare/legendary for aquarium\n        if rarity in (\"rare\", \"legendary\"):\n            rare_catches = player.get(\"rare_catches\", [])\n            rare_catches.append({\n                \"name\": fish[\"name\"],\n                \"weight\": weight,\n                \"rarity\": rarity,\n                \"location\": location_name,\n                \"caught_at\": now.isoformat(),\n            })\n            player[\"rare_catches\"] = rare_catches\n\n        # Calculate XP\n        base_xp = 10\n        rarity_mult = RARITY_XP_MULTIPLIER.get(rarity, 1)\n        weight_bonus = 1 + (weight / 50)\n        xp_gain = int(base_xp * rarity_mult * weight_bonus)\n\n        # Event XP boost\n        if active_event and active_event.get(\"effect\") == \"xp_boost\":\n            xp_gain = int(xp_gain * active_event.get(\"multiplier\", 1.0))\n\n        bonus_messages = []\n        boost_catches = player.get(\"xp_boost_catches\", 0)\n        if boost_catches > 0:\n            xp_gain = int(xp_gain * XP_BOOST_MULTIPLIER)\n            boost_catches -= 1\n            player[\"xp_boost_catches\"] = boost_catches\n            bonus_messages.append(f\"Rod boost! x{XP_BOOST_MULTIPLIER} XP.\")\n            if boost_catches == 0:\n                bonus_messages.append(\"The rod's glow fades.\")\n\n        extra_xp = 0\n        roll = random.random()\n        if roll < XP_BONUS_LARGE_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_LARGE_RANGE)\n            bonus_messages.append(f\"Treasure haul! +{extra_xp} XP.\")\n        elif roll < XP_BONUS_LARGE_CHANCE + XP_BONUS_SMALL_CHANCE:\n            extra_xp = random.randint(*XP_BONUS_SMALL_RANGE)\n            bonus_messages.append(f\"Lucky find! +{extra_xp} XP.\")\n\n        if player.get(\"xp_boost_catches\", 0) == 0 and random.random() < XP_BOOST_ROD_CHANCE:\n            player[\"xp_boost_catches\"] = XP_BOOST_ROD_CATCHES\n            bonus_messages.append(\n                f\"You found a better rod! Next {XP_BOOST_ROD_CATCHES} catches give double XP.\"\n            )\n\n        total_xp = xp_gain + extra_xp\n        player[\"xp\"] += total_xp\n        self._save_player(user_id, player)\n\n        # Record achievements\n        achievement_hooks.record_achievement(self.bot, username, \"fish_caught\", 1)\n        if rarity == \"rare\":\n            achievement_hooks.record_achievement(self.bot, username, \"rare_fish_caught\", 1)\n        elif rarity == \"legendary\":\n            achievement_hooks.record_achievement(self.bot, username, \"legendary_fish_caught\", 1)\n\n        # Perfect wait achievement (18-24 hours)\n        if 18.0 <= wait_hours <= 24.0:\n            achievement_hooks.record_achievement(self.bot, username, \"perfect_waits\", 1)\n\n        # Check level up\n        new_level = self._check_level_up(user_id, player, username)\n\n        # Build response\n        rarity_prefix = \"\"\n        if rarity == \"uncommon\":\n            rarity_prefix = \"an uncommon \"\n        elif rarity == \"rare\":\n            rarity_prefix = \"a RARE \"\n        elif rarity == \"legendary\":\n            rarity_prefix = \"a LEGENDARY \"\n        else:\n            rarity_prefix = \"a \"\n\n        response = (\n            f\"{self.bot.title_for(username)} reels in {rarity_prefix}{fish['name']} \"\n            f\"weighing {weight:.2f} lbs after waiting {wait_hours:.1f} hours! (+{total_xp} XP)\"\n        )\n        if bonus_messages:\n            response += \" \" + \" \".join(bonus_messages)\n        if forced_rare_applied:\n            response += \" A rare blessing guides your catch.\"\n\n        if new_level:\n            new_location = self._get_location_for_level(new_level)\n            response += f\" LEVEL UP! You're now level {new_level} and can fish at {new_location['name']}!\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_fishing_bless(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        target = match.group(1).strip()\n        target_id = self.bot.get_user_id(target)\n        player = self._get_player(target_id)\n        player[\"force_rare_legendary\"] = True\n        self._save_player(target_id, player)\n\n        self.safe_reply(\n            connection,\n            event,\n            f\"{self.bot.title_for(target)}, your next catch will be rare or legendary.\"\n        )\n        return True\n\n    def _cmd_fishing_stats(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        location = self._get_location_for_level(player[\"level\"])\n\n        xp_needed = self._get_xp_for_level(player[\"level\"])\n        xp_progress = f\"{player['xp']}/{xp_needed}\"\n\n        stats = (\n            f\"Fishing Stats for {self.bot.title_for(username)}: \"\n            f\"Level {player['level']} ({location['name']}) | \"\n            f\"XP: {xp_progress} | \"\n            f\"Fish: {player['total_fish']} | \"\n            f\"Biggest: {player['biggest_fish']:.2f} lbs\"\n        )\n\n        if player.get(\"biggest_fish_name\"):\n            stats += f\" ({player['biggest_fish_name']})\"\n\n        stats += f\" | Casts: {player['total_casts']} | Junk: {player['junk_collected']}\"\n\n        self.safe_reply(connection, event, stats)\n        return True\n\n    def _cmd_fishing_top(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        players = self.get_state(\"players\", {})\n        if not players:\n            self.safe_reply(connection, event, \"No one has gone fishing yet!\")\n            return True\n\n        # Get user map for display names\n        user_map = self.bot.get_module_state(\"users\").get(\"user_map\", {})\n\n        # Top by total fish\n        by_fish = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"total_fish\", 0) > 0],\n            key=lambda x: x[1][\"total_fish\"],\n            reverse=True\n        )[:5]\n\n        # Top by biggest fish\n        by_size = sorted(\n            [(uid, p) for uid, p in players.items() if p.get(\"biggest_fish\", 0) > 0],\n            key=lambda x: x[1][\"biggest_fish\"],\n            reverse=True\n        )[:5]\n\n        response_parts = [\"Fishing Leaderboards:\"]\n\n        if by_fish:\n            fish_list = []\n            for i, (uid, p) in enumerate(by_fish):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_list.append(f\"#{i+1} {name} ({p['total_fish']})\")\n            response_parts.append(\"Most Fish: \" + \", \".join(fish_list))\n\n        if by_size:\n            size_list = []\n            for i, (uid, p) in enumerate(by_size):\n                name = user_map.get(uid, {}).get(\"canonical_nick\", \"Unknown\")\n                fish_name = p.get(\"biggest_fish_name\", \"fish\")\n                size_list.append(f\"#{i+1} {name} ({p['biggest_fish']:.1f} lbs - {fish_name})\")\n            response_parts.append(\"Biggest Catch: \" + \", \".join(size_list))\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishing_location(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        current_loc = self._get_location_for_level(player[\"level\"])\n\n        # Check for active cast\n        active_casts = self.get_state(\"active_casts\", {})\n        if user_id in active_casts:\n            cast = active_casts[user_id]\n            cast_time = datetime.fromisoformat(cast[\"timestamp\"])\n            elapsed = datetime.now(UTC) - cast_time\n            hours = elapsed.total_seconds() / 3600\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}: Currently fishing at {cast['location']} \"\n                f\"(line out for {hours:.1f} hours). Level {player['level']}.\"\n            )\n            return True\n\n        # Build location progress\n        unlocked = [l for l in LOCATIONS if l[\"level\"] <= player[\"level\"]]\n        next_loc = next((l for l in LOCATIONS if l[\"level\"] > player[\"level\"]), None)\n\n        response = (\n            f\"{self.bot.title_for(username)}: Level {player['level']}, \"\n            f\"currently at {current_loc['name']}. \"\n            f\"Unlocked: {', '.join(l['name'] for l in unlocked)}.\"\n        )\n\n        if next_loc:\n            xp_needed = self._get_xp_for_level(player[\"level\"])\n            response += f\" Next: {next_loc['name']} at level {next_loc['level']} ({player['xp']}/{xp_needed} XP).\"\n\n        self.safe_reply(connection, event, response)\n        return True\n\n    def _cmd_aquarium(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        rare_catches = player.get(\"rare_catches\", [])\n\n        if not rare_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}'s aquarium is empty. \"\n                \"Catch some rare or legendary fish to display them here!\"\n            )\n            return True\n\n        # Group by rarity\n        legendaries = [c for c in rare_catches if c[\"rarity\"] == \"legendary\"]\n        rares = [c for c in rare_catches if c[\"rarity\"] == \"rare\"]\n\n        response_parts = [f\"{self.bot.title_for(username)}'s Aquarium:\"]\n\n        if legendaries:\n            leg_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in legendaries[-5:]  # Last 5\n            )\n            response_parts.append(f\"LEGENDARY: {leg_display}\")\n\n        if rares:\n            rare_display = \", \".join(\n                f\"{c['name']} ({c['weight']:.1f} lbs)\"\n                for c in rares[-5:]  # Last 5\n            )\n            response_parts.append(f\"Rare: {rare_display}\")\n\n        self.safe_reply(connection, event, \" | \".join(response_parts))\n        return True\n\n    def _cmd_fishinfo(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n        \n        # Get location argument\n        location_arg = match.group(1)\n        \n        if not location_arg:\n            # No location specified - show available locations\n            locations_fished = player.get(\"locations_fished\", [])\n            if not locations_fished:\n                self.safe_reply(\n                    connection, event,\n                    f\"{self.bot.title_for(username)}, you haven't caught any fish yet! \"\n                    \"Use !cast and !reel to start fishing.\"\n                )\n                return True\n            \n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, locations you've fished: {', '.join(locations_fished)}. \"\n                \"Use !fishinfo <location> to see fish caught there.\"\n            )\n            return True\n        \n        # Find the location\n        location = self._find_location_by_name(location_arg)\n        if not location:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, location '{location_arg}' not found.\"\n            )\n            return True\n        \n        location_name = location[\"name\"]\n        \n        # Get catches for this location\n        catches_by_location = player.get(\"catches_by_location\", {})\n        location_catches = catches_by_location.get(location_name, {})\n        \n        if not location_catches:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you haven't caught any fish at {location_name} yet!\"\n            )\n            return True\n        \n        # Get all fish available at this location for completion stats\n        all_fish = FISH_DATABASE.get(location_name, [])\n        total_species = len(all_fish)\n        caught_species = len(location_catches)\n        \n        # Group by rarity\n        caught_by_rarity = {\"common\": [], \"uncommon\": [], \"rare\": [], \"legendary\": []}\n        for fish_name, count in location_catches.items():\n            # Find the fish in the database to get its rarity\n            fish_data = next((f for f in all_fish if f[\"name\"] == fish_name), None)\n            if fish_data:\n                rarity = fish_data[\"rarity\"]\n                caught_by_rarity[rarity].append(f\"{fish_name} ({count})\")\n        \n        # Build response\n        total_caught = sum(location_catches.values())\n        response_parts = [\n            f\"{self.bot.title_for(username)}'s {location_name} catches: \"\n            f\"{total_caught} fish, {caught_species}/{total_species} species\"\n        ]\n        \n        # Add fish by rarity\n        for rarity in [\"legendary\", \"rare\", \"uncommon\", \"common\"]:\n            if caught_by_rarity[rarity]:\n                rarity_label = rarity.upper() if rarity in [\"legendary\", \"rare\"] else rarity.capitalize()\n                fish_list = \", \".join(caught_by_rarity[rarity])\n                response_parts.append(f\"{rarity_label}: {fish_list}\")\n        \n        # Send as multiple messages if too long\n        full_response = \" | \".join(response_parts)\n        if len(full_response) > 400:\n            # Send in parts\n            self.safe_reply(connection, event, response_parts[0])\n            for part in response_parts[1:]:\n                self.safe_say(part, target=event.target)\n        else:\n            self.safe_reply(connection, event, full_response)\n        \n        return True\n\n    def _cmd_fishing_help(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        help_lines = [\n            \"Fishing Commands:\",\n            \"!cast - Cast at your current level (can catch fish from any unlocked lower levels)\",\n            \"!cast <location> - Cast at a specific unlocked location (e.g., !cast pond)\",\n            \"!reel - Reel in your catch (wait 1-24 hours for best results)\",\n            \"!fishing - Show your stats\",\n            \"!fishing top - Leaderboards\",\n            \"!fishing location - Current location and level progress\",\n            \"!fishinfo - List locations you've fished\",\n            \"!fishinfo <location> - Show fish caught at a specific location (e.g., !fishinfo pond)\",\n            \"!aquarium - View your rare/legendary catches\",\n            \"!water - Celebrate finishing a water bottle (boosts rare fish, max 4/day)\",\n            \"\",\n            \"Tips: !cast pulls fish from your current level and any lower unlocked levels.\",\n            \"You can also travel back to previous locations to hunt for rare fish you missed!\",\n            \"Stay hydrated! Each bottle of water increases rare fish chances by 10% (up to 40%).\",\n        ]\n\n        for line in help_lines:\n            self.safe_privmsg(username, line)\n\n        self.safe_reply(\n            connection, event,\n            f\"{self.bot.title_for(username)}, I've sent you the fishing guide.\"\n        )\n        return True\n\n    def _cmd_water(self, connection: Any, event: Any, msg: str, username: str, match: re.Match) -> bool:\n        if not self.is_enabled(event.target):\n            return False\n\n        user_id = self.bot.get_user_id(username)\n        player = self._get_player(user_id)\n\n        # Get today's date\n        today = datetime.now(UTC).date().isoformat()\n        water_date = player.get(\"water_date\")\n        water_count = player.get(\"water_today\", 0)\n\n        # Reset counter if it's a new day\n        if water_date != today:\n            water_count = 0\n            water_date = today\n\n        # Check cooldown - must wait at least 1 hour between waters\n        water_last_used = player.get(\"water_last_used\")\n        if water_last_used and water_count > 0:\n            last_used_time = datetime.fromisoformat(water_last_used)\n            elapsed = datetime.now(UTC) - last_used_time\n            remaining_minutes = 60 - (elapsed.total_seconds() / 60)\n            if remaining_minutes > 0:\n                too_fast_messages = [\n                    (\n                        f\"I beg your pardon, {self.bot.title_for(username)}, but I find it rather difficult to believe \"\n                        f\"that you have consumed an entire bottle of water in {elapsed.total_seconds() / 60:.0f} minutes. \"\n                        f\"One does not wish to make accusations, but this has all the hallmarks of what I believe \"\n                        f\"the younger generation refers to as 'gaming the system.' Perhaps try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Most irregular, {self.bot.title_for(username)}. I have served in some of the finest households \"\n                        f\"in England, and I have never once witnessed a bottle of water dispatched with such supernatural haste. \"\n                        f\"Might I suggest actually drinking one? You may retry in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"Forgive me, {self.bot.title_for(username)}, but unless you have developed gills — \"\n                        f\"which, while fascinating, seems improbable — I rather suspect this water bottle is purely theoretical. \"\n                        f\"The next hydration opportunity presents itself in {remaining_minutes:.0f} minutes.\"\n                    ),\n                    (\n                        f\"I venture to observe, {self.bot.title_for(username)}, that the speed of your alleged consumption \"\n                        f\"would make even the most enthusiastic camel raise an eyebrow. One hesitates to use the word \"\n                        f\"'shenanigans,' but the evidence is compelling. Do try again in {remaining_minutes:.0f} minutes.\"\n                    ),\n                ]\n                self.safe_reply(connection, event, random.choice(too_fast_messages))\n                return True\n\n        # Check if they've already had 4 bottles today\n        if water_count >= 4:\n            self.safe_reply(\n                connection, event,\n                f\"{self.bot.title_for(username)}, you have already consumed your four bottles of water today! \"\n                \"Most commendable dedication to hydration. Do return tomorrow for further encouragement.\"\n            )\n            return True\n\n        # Increment the counter\n        water_count += 1\n        player[\"water_today\"] = water_count\n        player[\"water_date\"] = today\n        self._save_player(user_id, player)\n\n        # Calculate new boost percentage\n        boost_percentage = water_count * 10\n\n        # Build response based on how many they've had\n        if water_count == 1:\n            response = (\n                f\"Splendid! {self.bot.title_for(username)}, I am delighted to see you tending to your hydration. \"\n                f\"Three more bottles to go! Your commitment to wellness grants you a {boost_percentage}% boost \"\n                \"to catching rare and legendary fish today.\"\n            )\n        elif water_count == 2:\n            response = (\n                f\"Excellent progress, {self.bot.title_for(username)}! Two bottles down, two more to go! \"\n                f\"Your dedication is most admirable. You now have a {boost_percentage}% boost to rare catches.\"\n            )\n        elif water_count == 3:\n            response = (\n                f\"Marvelous! {self.bot.title_for(username)}, just one more bottle remains! \"\n                f\"You are nearly at peak hydration. Current boost: {boost_percentage}% to rare and legendary fish.\"\n            )\n        else:  # water_count == 4\n            response = (\n                f\"Outstanding! {self.bot.title_for(username)}, you have completed your daily hydration goal! \"\n                f\"I am exceedingly proud of your commitment to health. You now enjoy a magnificent {boost_percentage}% \"\n                \"boost to catching rare and legendary fish for the remainder of the day!\"\n            )\n\n        self.safe_reply(connection, event, response)\n        return True\n","structuredPatch":[{"oldStart":1358,"oldLines":6,"newStart":1358,"newLines":7,"lines":["         water_count += 1","         player[\"water_today\"] = water_count","         player[\"water_date\"] = today","+        player[\"water_last_used\"] = datetime.now(UTC).isoformat()","         self._save_player(user_id, player)"," ","         # Calculate new boost percentage"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b83cfbf7-fa64-4485-84fa-f63540c3825b"}
{"parentUuid":"4b9c1c5d-ffec-4309-abc5-bc67d0abc3f2","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","message":{"model":"claude-opus-4-6","id":"msg_01EVmS6wEk3S23Gaqr2wUihp","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Here's what I changed:\n\n1. **Added `water_last_used` field** to the player record to track the timestamp of the last `!water` use.\n\n2. **Added a 1-hour cooldown check** in `_cmd_water` — if less than 60 minutes have passed since the last use (and they've already had at least one today), it rejects the attempt with a randomly selected snarky message.\n\n3. **Saves the timestamp** whenever a water is successfully consumed.\n\nThe four rejection messages are written in Jeeves's voice — politely devastating, accusing the user of cheating without ever quite being so vulgar as to say it directly. Highlights include comparing them unfavorably to a camel, questioning whether they've developed gills, and noting that shenanigans are afoot."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":580,"cache_read_input_tokens":44149,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":580},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY3Hq9hfmPxUSj9Nf8S5R","type":"assistant","uuid":"b15d2473-a6df-4c83-a36a-a0beec316728","timestamp":"2026-02-12T01:16:12.347Z"}
{"parentUuid":"b15d2473-a6df-4c83-a36a-a0beec316728","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"d812d022-03f8-43c6-8beb-f62456b72347","toolUseID":"d812d022-03f8-43c6-8beb-f62456b72347","timestamp":"2026-02-12T01:16:12.393Z","uuid":"863af9ff-9d26-44b9-b518-f8ddb4618eee"}
{"parentUuid":"863af9ff-9d26-44b9-b518-f8ddb4618eee","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"system","subtype":"stop_hook_summary","hookCount":1,"hookInfos":[{"command":"entire hooks claude-code stop"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-12T01:16:12.765Z","uuid":"adf9d993-3944-4cf4-bc68-c686e852c251","toolUseID":"d812d022-03f8-43c6-8beb-f62456b72347"}
{"parentUuid":"adf9d993-3944-4cf4-bc68-c686e852c251","isSidechain":false,"userType":"external","cwd":"/home/nylan/code/jeeves","sessionId":"c896dd0a-a2f9-4151-8b9e-2001cd0296ac","version":"2.1.39","gitBranch":"main","slug":"virtual-wishing-cake","type":"system","subtype":"turn_duration","durationMs":38848,"timestamp":"2026-02-12T01:16:12.772Z","uuid":"3b58bf95-e283-4903-a667-1abdcbacf57e","isMeta":false}
